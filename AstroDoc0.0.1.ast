# BEGIN
# 21/04/17
# Astro 0.0.01

SINGLE-LINE COMMENTS
    # Hello, World!

MULTILINE COMMENTS
    #=
        I’m Dexter.
        #=
            Yay, nested comments!
        =#
        And I Rock.
    =#

SUBJECT DECLARATION & DEFINITION
    var a # unitialized subject declaration.
    var b = 25 = 50
    let c = 8

    # var is used for subjects whose values can change.
    # let is used for subjects whose values cannot change.

    # just like subjects, objects can also be let or var
    # new objects assigned to let subjects are let by default
    # new objects assigned to var subjects are var by default
    let beetle = var "BEETLE"
    var mantle = let "MANTLE"

    let b = 5 # covariant subject declaration.
    let d # uninitialized subject declaration.

    var Ω = 5, δ = 6 # multiple subject definition.
    let x, y, z

IDENTIFIERS
    # name of subjects must always start with a character and
    # can be followed with characters, digits or underscore.
    # names must not end with an underscore
    var name
    fun show99BottlesOfBeer:
        println lyrics

    # by convention, names use camel case style
    fun createMeme:
        println memes[rand]

    # by convention, subject and function names start with a lowercase character
    # by convention, type names start with an uppercase character.
    type Cat:
        let name, tag

ASSIGNMENT
    let pi, π = 3.141 # pi = 3.141, π = 3.141
    let pi & π = 3.141 # pi = 3.141, π = 3.141

    let one, two = (1, 2) # one = 1, two = 2
    let one & two = (1, 2) # one = (1, 2), two = (1, 2)

    # Bracketless zero-arg initializers are for specifying types only.
    let count = Int # Int is not a initializer call here. It's a type specification.

    let count = Int() # Int() is a initializer call here. count is initialized.

CONSTANTS
    let b # deferred constant initialization
    b = 56

    let d = Int() # d == 0
    d = 10 # error!

FUNCTION DEFINITION (1)
    # a typical Dexter function usually doesn't need brackets in its signature
    fun add a, b:
        return a + b

    # function calls are usually done without the braces except when necessary 
    var sum = add 25, 52

    fun div a, b: # parameters are 'let' by default
        return a + b

    fun mul a, b:
        return a * b

    # you can annotate the argument and return types of a function
    #:: Int, Int -> Int
    fun mod a, b:
        return a % b


EXPRESSION-ORIENTED
    var isNyproCrazy = faveHobby == 'CountingBirds' # returns true or false to isNyproCrazy

    fun add a, b:
        a + b # 'return' is not needed here. result of a + b will be returned to the caller.
    ..
    nypro.hieght = add aditya.height, -tripleo.height

    # a semi-colon at the end of a block, stops it from returning its evaluated
    # result
    fun setName p, name:#:: Person, Str
        p.name = name;
    ..

    let name = setName.('John Smith') # error! setName returns no result.

SPECIFYING TYPES
    var number = 5
    var todo = Str('Create a programming language')

    let salary = Pay # type specification
    salary = Pay(5_000, 12) # construction.

    var identifier = Str|Int # optional type specification.

    var address = Int = 506 # initialization
    let job = Str() # default costruction.

SOME BUILT-IN TYPES
    var index = UInt = 2_000 # UInt represents unsigned integer; no negative values.

    var debt = Int = -100 # Int represents signed integer; you can have negative values.

    let e = F64 = 2.718281828459045
    let dogBreed = Str = 'German Shepherd' # Str represents immutable UTF-8 string.

    var laptop = Chars = 'Alienware M18' # Chars represents mutable UTF-32 string.

    var listOfGroceries = ['Oranges', 'Cabbages', 'Tomatos', 'Bananas'] # this is a list.

    var game, year = 'BioShock Infinite', 2014 # this is a tuple.

VALUES & REFERENCES
    # by default primitive objects (UInt, Int, Float, Bool) are passed around by value and
    # by default complex objects (Str, user-defined types) are passed around by reference.
    var number = 502
    var account = getAccount('Dumbledore')

    # however, you can change this behavior with 'ref' and 'val'.
    var newAccount = val account # passing a complex object by value.
    var pointer = ref number # passing a primitive object by reference.

    # Dexter uses compile-time reference counting to manage memory, unlike Python or
    # Javascript which use runtime tracing GC.
    # It also does reference cycle breaking at compile-time. :)
    myCompany.affiliate = ref yourCompany
    yourCompany.affiliate = ref myCompany

    let myAccount = iso Account('Nypro')
    # iso means only the subject can hold a reference to the object.

    let trooperClone = acq trooper # acq is shallow copy operation.

    let player = team.player

    # you can specify a subject reference beforehand
    let library = acq

    fun getAmount:
        return rd amount # NEEDS REVIEW!!!
    # 'rd' means an object is passed by reference, but it cannot be written to,
    # only read from.

    fun swap a, b: #! ref, ref ->
        a, b = b, a;
    ..

NUMBERS
    var index = 5
    var axis = -3
    let meters = 0.25e-5
    let salary = 10_000f
    var color = 0x6FFF00p+12 # hex
    var opCode = 0b10110001 # bin
    var interest = 0o566768 # oct
    let pi = 3.14bf # BigFloat

ACCESS MODIFIERS
    var money = 0 # subjects, functions, types, etc. are public by default.

    fun `sub a, b: # becomes inaccessible outside module
        a - b

    var *pi =  3.14 # becomes read-only outside module

TUPLES
    var name, age = 'Emeka Okorafor', 27 # this is an open tuple
    # name and age are assigned to 'Emeka Okorafor' and 27 correspondingly.
    
    var game, year = ('Uncharted 4', 2016) # this is a closed tuple
    # game and year are assigned to 'Uncharted 4' and 2016 correspondingly.

    # NOTE: an open tuple is passed by value, a closed tuple is not
    name, age = age, name

    let make, year = car.details()

    let index, car = 15, ('Ferrari', 1995) # car is a tuple.

    let map = () # empty tuple

    # named tuple
    let http200Status = (statusCode: 200, description: 'Ok')

PROPERTIES
    # properties provide getter/setter behavior.
    var age =
        set value:
            this = value # this refers to the property itself
        get:
            this

    # `this = <arg>` is always provided for set unless overridden.
    # a closing `this` is always provided for get unless overridden.

    var age = set \\ get # same as above

    var delegatedProperty =  set x: delegateSet \\ get: delegateGet

LAZY EVALUATION
    # an operation marked lazy will only execute on access of subject, not before
    let appComponent = lazy iso self.getAppComponent
    var lazyField = lazy
        set x: println "I'm lazy!"


LISTS
    var unorderedList = [7, 3, 8, 5, 4, 0, 9, 1, 2, 6]

    var emptyList =  []

    var names = [Str] # list of type specified

    var contestants = [Str]['Steve', 'Aditya', 'Sizwe', 'Pierre']

    # Dexter uses 1-based indexing, so every list indices start at 1.
    var disqualified = contestants[1..4]

    var reversed = contestants[-1..] # -1 is the 1st index from behind, i.e. the last index.

    let myGarage = [Car][('Mustang'), ('Eleanor'), ('Bugatti'), ('Lamborghini')]

    let yearSalary = [Int]{12}[] # you can specify a size for the list.

    yearSalary.[1..3] = [2_000, 2_000, 2_500]

    let calendar = {12}[]

    # GOTCHA!: the space between a name and a pair of braces matter
    value [4] # this is a function call with one-element list as argument
    value[4] # this is accessing the 3rd element in value 

    # proposed operations with lists.
    var concatenate = [1, 2] ++ [3] # [1, 2, 3]
    var multiply = [1, 2] ** 2 # [1, 2, 1, 2]
    let subtract = [1, 2, 3, 4, 3] -- [4, 3] # [1, 2]
    let divide = [1, 2, 5, 6, 3, 4] // [5, 6] # [[1, 2], [3, 4]]

MATRICES
    # Dexter lists can be used as matrices
    let a = [
        1, 2
        [3, 4, # this line is [3, 4, 5, 6]
        5, 6]
    ]

    var matrix = [Int]{22}[
        1, 0
        0, 1
    ]
    var column2 = matrix[1.., 2] # content on row 1 to end, on column 2.

    var matA = [age]{2}[,] # 2 rows with unknown column length

    matA.[.., ..] = [
        [1, 6, 3]
        [3, 7, 4]
    ]

    let subset = mat4[1.., 1..2]
    var matB = matA * 2

    # vectorised operations # NEEDS REVIEW!!!!!!
    var matA = matB .* matC # the preceding `_` signifies an element-wise operation.
    matA .dot. matB

    # Dexter's lists are by default, row-major order, but you can make it
    # column major by using the transpose function
    let y = [1, 2, 3]
    # 1 2 3

    let z = [1, 2, 3].transpose
    # 1
    # 2
    # 3

    let x = y[..2].transpose

    # splatting a list
    let a = [
        1, 2
        0, 4
    ].transpose

    ...a
    # 1 0
    # 2 4

    # splatting a list exposes the content of the matrix as an open tuple
    # splatting a returns a 2-dimensional open tuple.
    let b = [
        ...a.transpose, ...a.transpose
        ...a.transpose, ...a.transpose
    ]
    # 1 0 1 2
    # 2 4 0 4
    # 1 2 1 0
    # 0 4 2 4

DICTIONARIES
    # dictionaries are basically key-value lists.
    let family = [
        'mum':
            'name': 'Esther Williams'
            'age' : 41
        dad: # unquoted keys are taken as strings
            name: 'Sunday Williams'
            age : 46
        sister:
            name: 'Shade Williams'
            age: 15
    ]

    let sisterName = family['sister', 'name']

    # to use variables from the outer scope, the variable name needs to be escaped wit `\`
    var professor = [
        \id1: 'Charles Xavier'
        \id2: 56
    ]

    let testScores = [
        'class room 1': [0, 15, 30, 15, 76, 50],
        'class room 2': 45, 50, 83, 9, 39, 81
    ]
    var class1Scores = testScores['class room 1']

    var contacts = [:] # empty dictionary
    var user = [Str:User]{2, 2}[:]
    var scoreList = [Str:Int]

LISTS, DICTS, INCLUSION, DIMENSIONS # NEEDS REVIEW !!!!!
    var a = [] # a list
    var b = [,] # a list containing another list
    var x = [:] # a dict
    var y = [::] # a dict containing another dict
    var z = [:,] # a dict containing a list
    var b = [,:] # a list containing another list, which contains a dict.
    var t = [Str Int]{12}[:]
    var u = [Str Str Int]{7, 5}[::]
    var u = [Str Int]{60, 5}[:,]

OTHER TYPES OF LISTS
    var range = [1..20] # range is a type of list
    var indexer = list[1..] # indexer is a type of list.
    # it holds ref to a subset of another list


PACKING & UNPACKING
    var list = [for x = [..10]: yield x] # [ ] turns a generator into a list.
    var open = ...list # ... turns a generator, list or closed tuple to an open tuple.
    var closed = (a, b, c) # turn an open tuple to closed tuple

    let primes = [2, 3, 5, 7, 11]
    let numbers = [2, 4, 8, ...primes]

REST
    var a, ...b = 1, 2, 3, 4

    fun sum a, ...b:
        a + b.foldLeft 0, |x, y| => x + y

RANGED VALUE
    var height = 3d``7d
    height = 6d
    height = 8d # error

    fun isPrime n = 2``:
        math.isPrime n

    isPrime 24
    isPrime 1 # error

STRINGS
    let language = 'Dexter'
    let year = 2015
    var story = "[language] was started in [year]" # string interpolation.

    let calc = '5 * 50 = [5 * 50]'
    # both single and double quotes can be used to represent a string literal.

    # String formatting
    println "The price is [price.%0.2f]"

    # non-standard string literals preceded by characters are not affected
    # by escape sequences, because they are processed verbatim.
    var verbatimStr = r_"Use '\t' to represent tab"

    # here string (DEPRECATED). first and last new lines are always ignored.
    var verbatimStr = '''
    Hello, World!
    '''

    var string = 'Hello' # Str
    var chars = ch.'Hello' # Chars

    # proposed operations with strings.
    var concatenate = 'ab' + 'c' # 'abc'
    var multiply = 'ab' * 2 # 'abcabc'
    let subtract = 'abcac' - 'ca' # 'abc'
    let divide = 'abcdeabc' / 'de' # ['abc', 'abc']
    let escapeSequences = '\t \n \' \" \[ \# \\'

    # multiline string.
    var greeting = 'Hello,'
        'World!'

MULTILINE EXPRESSIONS
    # expressions that spread accross multiple lines must be enclosed in brackets
    # or used with an isolated three dots ending the previous line.
    var zero = -100 ...
    + 100

    # notable exceptions:
    # statements expecting a block-begin punctuator like ':' or '='
    if x < y
    & a == b:
        doTask

    var languageDesigner =
        "Steve Akinyemi"

    # comma operator
    sum 1, 2, 3, 4, 5, 6, 7, 8,
    9, 10, 11, 12

BLOCK SCOPE
    # a block represents a scope
    let country = 'India'
    block:
        let country = 'Nigeria'
        println country # Nigeria

    println country # India

    # multiple statements can be written on one line separated by semi-colons.
    var temp = a ; a = b ; b = temp

    # multiple blocks can also be written on the same line using the '\\' punctuator.
    if studio.isLive: blockAccess \\ else: openAccess

INDENTATION # NEEDS REVIEW!!!!!!
    # Dexter is an indentation-based language
    if x == y:
        if a == b:
            doTask
    # indentation is used here to disambigute if-else association
    else:
        doNothing

    let myName = " Nypro "
        ->trim!
        ->reverse!
        # indented dot/arrow notation links with the argument of the previous  line.
    ->println

    play music
        'Asa',
        'Jailer',
        '2009'
        # arguments to function can be laid out on the next indented lines
    .rewind 2

    var x =
        25 + 6
        # a continued line following an assignemnt operator should be indented


SANDWICHED STATEMENTS
    var faveSoccerClub =
    (team == 'Manchester United' ? (println 'You suck!'; team) : _)

    # you can sandwich multiple expressions where a single expression is expected.
    # by putting them in brackets.
    println.('Hello, ', (println.('World'); '!'))
    var add = ()

IF STATEMENT
    if isAdrianRich:
        spendAll 'on parties'

    elif isOroboRich:
        spendAll 'on legos'

    elif isSyconRich:
        spendAll 'on suits'

    else:
        cry 'we are broke'

    if phoneNumber == nil:
        useEmail

    if let stockCode = getStockCode.('APPLE'): # block is evaluated if stockCode is not nil
        println 'APPLE: [stockCode]'

    if copy = getCopy:
        println copy

    # nested if statements can be written together with their corresponding
    # else statements stacked accordingly
    if tim.age > 16, if car.state == 'good':
        tim.drive car
    else:
        raise Error 'Driver must over the age of 16'
    else:
        raise Error 'Car is in bad state. Repair immediately!'

NIL
    # sometimes, it is important to represent an empty or missing state, this can be
    # achieved in Dexter with optional typing.
    var code = Str # cannot be nil
    var program = Str|Nil = 'println \"Hello World\"'
    var anotherProgram = Str? = nil

    # a nilable cannot be assigned to a non-nilable subject without a proper nil coalescing with a fallback value.
    var programList = Str()?
    var cartoonList = [Str?]

    let profile = server
        .user('Name')?{Account 'default'}
        .profile?{Profile 'default'}

    if feeds: println 'no feeds' # = if feeds equals nil or false.

    (getAccount "default")?

    # nil-then-raise operator
    getAccount("Default")?! # if result is nil, raise NilError
    game.fix?!

    if isRecieving == nil:
        println 'remote server stopped recieving'

    let john = Person dave?.name # unwrapping a nilable object

    var isNight = true?

    if isNight:  # error # disambiguation needed
        wake dracula

    if isNight = true:
        wake dracula

CONDITIONS
    # Dexter discourages reptition in conditional expression.
    x < y & y < z # deprecation warning!
    x < y < z

    x == y & y == z # deprecation warning!
    x and y == z # if both x and y equals z.
    x == y == z

    x == y | y < z # deprecation warning!
    x == y or < z # if x equals y and also greater than z.

    x == y & a == b # no warning

    if x != y: println 'x does not equal y'
    if x not in list: println 'x is not inside list'
    if !x:  println 'x is not nil'

    a.trim == b.trim
    |a == b|.trim

    #: Node -> Bool
    fun isSymmetric node:
        node.|right == left|.height

FOR LOOP
    for i in [1..10]:
        println i

    let interestingNumbers = [
        'prime' : 2, 3, 5, 7, 11, 13
        'square' : 1, 2, 4, 9, 25, 36
        'fibonacci' : 1, 1, 2, 3, 5, 8
    ]

    for kind, number = interestingNumbers: # parallel pairing through a dictionary.
        println '[kind]: [number]'

    # an extra tuple param serves as the iteration index
    for names, index = register:
        println index, names

    for name, (key, value) = nameList, table:
        println name, key, value

    # looping through a number
    for num = 50: num

    for up, down = [1..20], [20..1]: # parallel pairing through ranges.
        println '[up] :: [down]'

    for upper = [1..20], for lower = [1..20]: # nested iterations through ranges.
        println '[upper] :: [lower]'

    for i = [1..20]:
        i += 1 # error! immutable subject.
        j = i
    ..

    for var i = [1..20]:
        i += 1
        j = i`
    ..

    for _ = [1..fifty]:
        println 'Hello'

LIST COMPREHENSION
    var oddList = [for i = [1..20], where i .mod 2 != 0: yield x]
    var oddList = x << x = [1..20] ~ x .mod 2 != 0
    fun times: x * y << x = [1..10], y = [20..1] ~ even y

BLOCK SUBJECTS
    for color = colors:
        var hold i = 1 # a block subject's state persist for the duration of the loop.
        printl=i, color)
        i += 1
    ..

    fun sum list:
        var hold index = 1 # you can also have block subjects for recursive functions.
        if x.size < 1:
            return 0
        else:
            list.[index] + sum.(list.[++index:])
    ..

EXT
    # `ext` is used to refer to the outside scope
    for class = classes:
        for student = students:
            if student.position == 'captain':
                record.save.(student.name)
                continue ext # refers to parent loop scope
        ..
    ..

    fun add a, b:
        fun plus:
            if a and b > 0:
                return ext a + b
        plus
    ..

    new view.addListener obj Listener:
        fun onScroll view, dX, dY: #: View?, Int, Int
            scrollList.each |it| =>
                it.invoke ext.self
    ..

BREAK WITH
    for name = register:
        if name == 'Tony':
            break name
        ""

IN
    if student.name in defaulterList:
        println '[student.name] hasn\'t paid yet. Contact parents'

    if 'ps4' not in birthdayPresents:
        println 'Aaargh! Everyone hates me'

    if /dollar[s]?/ in sentence:
        println 'Change occurrences of "Dollar" to "Pound"'

WHERE # @INC
    # where is used to establish an extensive condition especially where it is
    # not expected.
    if person in auditionRoster, where person.mark > 40.0:
        acceptanceList.add person

    for book in library, where book.title.contains.('adventure'):
        personalLibrary.add book

WHILE LOOP & LOOP
    while file.hasNext:
        println file.next
    ..
    # loop
    loop: # synonymous with while true
        println '>>> '
        let input = scan
        let tokens = lex input
        let ast = parse tokens
        let bytecodes = compile ast
        let result = interpret bytecodes
        println result

    redo:
        lines = gen.readLine # evaluated at least once.
    while gen.hasNext

    while user = genRandomUser:
        println user.name

    while list.size > 0, for name = list:
        print name, sp
        list .removeTop

TERNARY OPERATOR
    # ternary operator is a summarized if-else clause.
    var absValue = if a > 0: a \\ else: -a

    var absValue = a > 0 ? a : -a

    song in playlist ? play playlist.[song] : _

    # a ternary operator statement needs to be encapsulated in brackets
    # where a semicolon is expected
    if a == (b > c ? b : c): print a

FUNCTION DEFINITION (2)
    fun multiply a, b:
        a * b

    # if a function returns nothing, it's return type may be `!` or left empty
    #:: Str -> !
    fun greet name:
        println "Hello [name]"

    # to make sure nothing is returned from a function you can use `;` to terminate an exit expression or `_` as the exit expression.
    fun effect mood:
        if mood.isHappy:
            happySong->play;
        else:
            sadSong->play;

    # varargs.
    #:: Int -> F64
    fun arithMean ...numbers:
        var total = 0d
        for number = numbers:
            total += number
        total / numbers.size
    ..

    # there are two ways of calling a function in Dexter
    arithMean 1, 2, 3, 4
    arithMean(1, 2, 3, 4)
    # but the former is usually used 

    # GOTCHA!: this two function call return different results
    toUppercase ('hello ' + name).toLowerCase
    toUppercase('hello ' + name).toLowerCase

    # anonymous functions are nameless functions
    # and they are excuted at the point of declaration.
    fun _:
        return a + b

    # the states of `keep` subjects are preserved between function calls.
    fun callCount:
        var keep count = 0
        println '[count += 1]'

    callCount # 1
    callCount # 2

    # functions that change values of arguments must be annotated with `!`.
    #! ref Person, ref Person
    fun swap a, b:
        a, b = b, a;

    swap john, jane

    # when an argument name isn't given, they can be referred to with their argument notation
    fun add _, _: $1 + $2

    # default parameter values and shared value with `&` binder
    fun login email & username & password = 'demo':
        access Account username, password

    login(_, 'nyprothegeek', 'bazinga!')
    login('nyprothegeek@gmail.com', 'nyprothegeek')

    # compulsory named arguments
    fun signUp username., password.:
        access Account username, password

    signUp username:'appcypher', password:'bazinga'

    fun sendMessage message, to.recipient:
        println (message + recipient).toUppercase

    sendMessage 'Hello', to:'Cantell'

    fun sum first., ...rest.: 
        first .+ rest

CONSECUTIVE CALL CHAIN
    greet 'John'; greet 'Jane' ; greet 'Lagbaja'
    greet 'John' >> 'Jane' >> 'Lagbaja'
    greet->('John')->('Jane')->('Lagbaja')

    list.getPerson 'Anthony', >> 'Barney', >> 'Rodney'

FIRST-CLASS FUNCTIONS
    # creating new functions from existing functions
    var details = getDetails$ User
    var plus = add$ 0, 0
    fun times = mul F64, F64

    var binaryOp = (Number, Number -> Number)
    var binaryOp = Func{Number, Number, Number}

    var range = fun _:
        for i in [..11]:
            yield ++i

    # passing functions to functions
    fun compress image, f: #! Image, (Int, Str -> Int)
        f image

FUNCTIONS AS ARGUMENTS & LAMBDAS
    let scoreListWithExtraMarks = scoreList.map (fun _ score: score + 5)
    let scoreListWithExtraMarks = scoreList.map markFilter$ Int

    fixtureList.filter |game| => !game.isCancelled
    fixtureList.filter => !$1.isCancelled

    var pplBelow25 = census.filter |person| => (
        person.age += 1
        person.age < 25
    )

CLOSURE
    # a closure is an inner function.
    fun genDBConnector host., username., password.:
        return fun makeDBConection: # a closure can be returned.
            db.connect.(host, username, password)
    ..
    var dbCallback = genDBConnector.(host:'localhost', username:'nypro', password:'willdiearobot')

COFUNCTIONS
    fun remove list, index: #!
        list -= list.[index]

    (remove$ [F64], Int) += refreshUI$ # attaching a cofunction.
    emit movieList.remove.(2) # emit is used to run the function along with its cofunctions.

EXT SUBJECTS
    let state = 'Idle'

    fun changeState state:
        if state != nil:
            activateState state
        else:
            activateState ext.state # ext refers to the parent scope.
    ..

USEFUL FUNCTIONS
    typeOf 24
    size [1, 2, 3, 4] # size is a constant-time operation.
    count("Hello, world!") # count may be a linear-time operation.
    iter array, 5 # array{5:3}
    enumerate array # for x, y in array
    map names, => $1 + ' '
    filter(list, |a| => isPrime a)
    each list, => (println $1, ', ')
    eachIndex list, |i, e| => println "[i]: [e]"
    noneMatch numbers, |a| => isEven a
    printf('The circumference of a circle with radius 5 is %f', pi * 5^2)]
    respondsTo(object, add$)
    getHighest list
    getLowest list
    getRank list, 21

USEFUL CONSTANTS
    nl == '\n'
    sp == ' '
    tb == '\t'
    cm == ', '
    bk == '\b'
    pi == 3.141_592_653_589
    e == 2.7182818284590

CACHED EXPRESSION
# sometimes one needs to cache an expression for an iterative task, without declaring a variable.
for i = [1..keep 35*2]:
    println i

PATTERN MATCHING
    # match block is like switch-case statement, and it matches against the expression on the previous line.
    object
    | 0: 1
    | n: n * fact n  - 1
    | [x, ...y]: x
    | (x, y): y + b
    | [a:b]: a
    | [a..b]: a, b
    | 1``20: 10
    | Int: 'This is an integer'
    | a = []: a ++ [1, 2, 3]
    | \outer: outer
    ~ object.name == 45: 45
    ~ x > 25: 'Greater than 25'
    | else: 'Hello'
    | _: 'Hi'

    # it can also match against the arguments of a function or loop
    fun status message:
        | Int: println message
        | Started("Fail"): println message.info
        | Started(info): println info # named match
        | Started(\info): println message.info
        | Terminated("Success"): println message.info

    while turn != 'y' or 'Y' or 'n' or 'N':
        | 'y' or 'Y': return 1
        | 'n' or 'N': return 0
        | else: print "its an invalid choice."

COROUTINES # NEEDS REVIEW !!!!!!
    # Coroutines run concurrently, but cannot run parallely.
    fun genRandRange num:
        yield rand range:num
    ..

    var gen = for i in [1..45]: yield i

    # indexed yield
    let gen3 = yield[3] of gen
    let take3 = [yield[3..7] of gen]

ASYNC AND AWAIT # NEEDS REVIEW !!!!!!
    fun asyn getPerson name:
        let p = await getPersonFromServer name.split /\s+/
        yield p->name, ->age
    ..

TASKS, also ACTORS # NEEDS REVIEW !!!!!!
    task Task:
        var name, time = Str, Int

    fun Task name:
        self.name = name
        self.time = random([1..1_000])

    fun sleep actor: #:: Task
        println "[name] is sleeping for [time]ms"
        sleep time
        println "[name] is done"

    var
        t1 = Task.("Task-1") ->sleep
        t2 = Task.("Task-2") ->sleep
        t3 = Task.("Task-3") ->sleep

STREAM
    ones.twos.threes.collect
    collect(threes(twos(ones())))

    fun ones: yield 1
    fun twos generator: yield gen + 2
    fun threes generator: yield gen + 3

    fun collect generator:
        list = []
        for i in gen: list .append i
        list
    ..

TYPE DEFINITION
    type Car:
        var make, model = Str

    fun move car: #:: Car
        "Moving"

    # initializer
    fun Car make, model: #:: Str
        new.(make, model)
    # new is a special function that creates a new object and maps
    # the arguments to corresponding fields

    fun Car maker, model, year
    fun Car ~ # normal # called on Car object during destruction.
    fun Car ! # exception # called on Car object during an exception.

    type Person: var name, age # Person is a initializer type.
    # Initializer types have just main initializer and the parameters
    # of the initializer are mapped to fields.

    var john = Person.('John Connor', 23)

    type Lamp: var color
    var yellowLamp = Lamp 'Yellow'

    # initializer overloading
    fun Lamp:
        Lamp 'White'

    type DataProviderManager:
        # a `keep` field is a type level field
        let keep allDataProviders = get \\ set

    # associated type # NEEDS REVIEW!!!!!
    type Person.Pet var name & age

    let pet = Person.Pet 'maddison', 2

FIELD EXTENSION
    type Programmer specializedLanguages <: Person:
        let languages = [Str]

    let orobogenius = Programmer
    orobogenius.languages = ["Java", "PHP", "JavaScript"]

    let appcypher = Programmer ["Dexter", "Java", "C++"]
    appcypher.new.philosophies = ["Open Source", "Transhumanism"]
    appcypher.new.resume = "chicken.poop.com/appcypher"
    appcypher.new.mentor = "Captain Jack Sparrow"

    var nypro = appcypher

TYPE EXTENSION
    type Programmer specializedLanguages <: Person:
        let languages = [Str]

    # the `fork` keyword allows a type to be extended within a scope.
    type fork Programmer:
        var philosophies, resume, mentor

INHERITANCE
    type Animal
    fun sound animal: #:: Animal
        println 'Nothing'

    type Bird <: Animal
    fun sound bird: #:: Bird # overrides supertype function.
        println 'Chirp!'

    type Horse <: Animal:
    fun sound horse: #:: Horse
        println 'Neigh!'

    # Dexter supports multiple inheritance.
    type Pegasus <: Horse, Bird:
    fun sound pegasus: #:: Pegasus
        sound pegasus as Horse

    # due to Dexter's multiple dispatch, Inheritance applies equally to all
    # arguments of a function.
    type A
    type B <: A

    fun
        foo a, x #:: A, X
        foo b, x #:: B, X # this overrides top

    fun
        bar x, a #:: X, A
        bar x, b #:: X, B # this also overrides top

    # a super method can be called directly or by using super
    fun baz x, b: #:: X, B
        baz x, b as base

INITIALIZER TRAIN
    # initializer train is the way Dexter ensures the initialization of all declared and inherited fields of a particular type.

    # it's basically about making each type responsible for the initialisation of the fields it introduced.

    type Person name

    type Teacher subject <: Person
    type Student course <: Person
    # the initializer train of an initializer type is created automatically

    type TeachingStudent <: Teacher, Student:
        var schedule

    fun TeachingStudent name, subject, course, schedule:
        new {name : subject : course}, schedule
        # (name, subject) is passed to Teacher
        # (<delegated>, course) is passed to Student

    # a sub type should not assign to inherited fields in the initializer.
    # if the compiler finds out an initializer doesn't initialize a field, it complains.

DIAMOND PROBLEM
    fun register teacher: #: Teacher
        staffList teacher.name

    fun register student: #: Student
        studentList student.name

    # when TeachingStudent type is declared, an ambiguity error will be issued about `register`.

    # the function needs to be overridden
    fun register teachingStudent: #: TeachingStudent
        staffList teachingStudent.name
        studentList teachingStudent.name

    var john = TeachingStudent 'John Smith'
    john.register

    # as a result of these MI issues, Astro advocates favoring single inheritance and composition over multiple inheritance.


ABSTRACT TYPES & FUNCTIONS # @INC
    type abst Player # abstract types cannot be instantiated.

    # a function without a body (apart from initializers) is an abstract function and an error is raised if it is called directly.
    # An abstract function is expected to be implemented by a corresponding subtype function.
    fun play pl #: Player
    fun rewind pl #: Player
    fun fastForward pl #: Player

    type DigitalPlayer <: Player
    fun play dpl: #: DigitalPlayer # this overrides and implements play.
        initPlaylist
        playPlaylist

    # Here is an example using abstract types to simulate Algebraic Data Types.
    type abst Tree

    #:: $T -> Leaf
    type Leaf value <: Tree

    #:: Leaf, Tree -> Node
    type Node l, r <: Tree

    #:: Tree -> _
    fun sum t:
        | Leaf: t.value
        | Node: (sum t.l) + (sum t.r)
    ..

    var x = Node.(Leaf.(1), Node.(Leaf.(2), Leaf.(3)))

SINGLETONS
    obj Switch: 
        var on = false

    fun toggle switch: 
        switch->on ? ->on = false : ->on = true


ANONYMOUS TYPES # @INC
    # an anonymous type is a singleton with an ad hoc type definition.
    # which include the type's fields and functions.
    (obj <: Thread state:
        var state = 'Paused'
        fun start:
            println 'Thread: [self.state]'
    )('Working')

    var currentShow = (obj show, host) 'DareDevil', 'Netflix'

    println currentShow.host

    window.addMouseListener obj <: MouseAdapter:
        #: MouseEvent
        fun mouseClicked e: _
        #: MouseEvent
        fun mouseEntered e: _

TYPE CHECKING
    if myCar :: Car:
        println 'myCar is a Car'

    if myCar == Car:
        println 'myCar is a Car or its subtype'

    if myCar <: Car:
        println 'myCar is a supertype of Car'

    if myCar !>: Car:
        println 'myCar is not a supertype of Car'

    (head$ List) :: ([_] -> _)

REFERENCE CHECKING
    let a = Person 'John Smith', 25
    let b = a
    let c = val a
    a =:= b # true
    a =:= c # false
    (one =:= other) == (one.ref == other.ref) # true

FUNCTION == METHODS (UFCS)
    fun show p: #: Person
        println(self.name, self.age)
    ..

    show nigel
    # In Dexter, a function is a method of its first argument.
    nigel.show

    # The only two set of functions that cannot be used with dot operator are
    # contructor functions and new functions.
    type Robot:
        var name, uniqueID
    ..

    fun Robot name, uniqueID:
        new name, uniqueID

    var wall_e = Robot 'Wall•E', 215


ACCESS CHAINING/SHRINKING
    # return chain.
    var result = 8.plus(6).minus(4).times(2)

    # tail object chain
    # a convenience syntax in which the intial associated object forms a long chain of access.
    profile ->open ->deleteMsgs ->close

    # returned object forwarding.
    buffer ->resize(13) ->fill(0, $0)

    # consecutive call chain
    var nameList = [Str]
    nameList.add 'Badmus' >> 'Travis' >> 'Gabriel'

    # chain tupling
    var name, version = haskell ->name, ->version
    var first, second = getPerson 'Seamus', >> 'Flinn'

    # shared dot or arrow
    |a == b|.size ? a : b
    println john.|name, addrress|.toUppercase

COVARIANCE
    type Person (name, age)
    type Employee {name, age}, job <: Person
    type Teacher {name, age}, course <: Person

    #: Person
    fun show p: # a covariant parameter can take a subtype too.
        println p.name, p.age

    show Person 'Tony Stark', 36
    show Employee 'Peter Parker', 17, 'Photographer'
    show Teacher 'Diana Lane', 12, 'Biology'

    var people = [Person][Teacher(), Employee(), Employee()] # a covariant list.

TYPE CASTING
    var radianInt = Int.(2 * pi) # the resulting value Float of 2*pi is casted to Int.

    fun Employee person: #:: Person
        Employee(self->name, ->age)

    var deitel = Person('Paul Deitel', 57)
    var editor = Employee dietel

    var yearStr = Str 1990
    let sorted = Int yearStr.sort!

    #:: Float -> MyInteger
    fun MyInteger num: new.(Int num)
    let cost = (MyInteger price) * qty

NAME ALIASES
    type Number = Integer|Float|Complex
    fun cheb = chebyshevCoefficient
    let pi = thisIsAPiConstant

FUNCTIONS OBJECTS & SUBJECTS
    fun foo = bar(5, 6)

    var
        qux = 5
        doo = bar$('a', 0)

    fun mix a:
        | 1: fun add a, b: a + b
        | 2: 25

    fun baz = mix 1 # error
    var bin = mix 1

MODULES AND IMPORTS
    # when you import a module, every public member is imported into the namespace.
    import:
        .appy.BananaTree
        com.nypro.[AppleTree, GuavaTreeTree]

    # if you want to import members namespaced
    import:
        com.appy.BananaTree!
        com.nypro.[AppleTree!, GuavaTree!]

    # import all
    import:
        com.appy.BananaTree
        com.nypro.[?]

    # import some
    import:
        com.appy.BananaTree(Trunk, grow)
        com.nypro.[AppleTree(Leaf, Apple), GuavaTree!(grow, Seed)]

    # import by category
    import: com.appy.BananaTree(var, let, fun, type, enum)

    # don't import
    import: com.appy.BananaTree(fun: grow)
    # names on the left of the `;` are not imported

    # global subjects can only be passed by value from one module to another.

GENERICS
    # declaring a generic type T.
    #: $T<:Number, T, T -> T
    fun add a, b, c:
        var d = T
        d = a + b + c

    # yielded type
    #: [($T, T)] >> T
    fun bmi xs:
        fun bmi weight, height: weight / height ^ 2
        bmi w, h << (w, h) = xs

    var sum = add{Int} 2, 4, 6
    # if the generic parameter can be readily inferred, then type argument can be ommited.
    var sum = add 2, 4, 6

    # in case you want a type of function to have its generic arguments in certain order
    # you can put it in a type annotation surrounded by braces
    type MyList: #: {$T, &len::Int} 
        let list = [len T][]
        let size = len

    var list = MyList{Int, 5}

    # exhaustive generics
    #: MyList{$T}, $U -> T, where U::MyList.U
    fun getItem list, index:
        list[index]

    let identifier = $T<:Identfiable

    var pegasus = $U(<:Horse, <:Bird)

    var x = 10
    let y = typeOf x # this makes y have the same type as x

TYPE OBJECTS # @INC
    # unconventionally, Dexter has Type objects which can be held by subjects.
    # Sometimes, this concept may clash with generics, but they are basically different
    # constructs with overlapping features.

    var number = typeOf Bool # covariant subject
    # number can hold Bool.type or its subtypes.

    Int <: Integer # true

    fun haveSameTypes x, y:
        x and y == typeOf x
    ..


ENUMS
    # in a way, enums are types that contain declaration of subtypes.
    enum Days:
        sunday, monday, tuesday, wednesday, thursday, friday

    var today = Days = friday
    today = tuesday

    fun todo day: #: Days
        | sunday: sleep
        | monday: work
        | friday: tgif
    ..

    enum Integral:
        unsignedIntegral(value) #: Unsigned
        signedIntegral(value) #: Unsigned
    ..

    # enums can have field too, which enum elements inherit
    enum Cars:
        let make, model
        mustang
        ford
    ..

    # enums can inherit from other enums and types.
    # it's more of inclusion than inheritance
    enum NewTools <: OldTools:
        unity,
        django,
        sass
    ..

    # Algebraic Data Types
    enum Tree:
        leaf value #: Int
        node left, right #: Tree, Tree
    ..

    fun sum t = Tree:
        | leaf v: v
        | node(l, r): sum(l) + sum(r)
    ..

MODIFIER ANNOTATIONS
    fun calculateSpeed ball: #> asyn
        angularVelocity ball.diameter

    fun play: #> task
        ping pong

    var keep xafora = await foo

    type Pandora galacticConstellationNumber #> abst

    type NewTask #> task

    enum Days:
        sunday, monday, tuesday, wednesday,
        thursday, friday, saturday
    ..

OPERATOR OVERLOADING
    # special characters
    # these are characters that cannot be combined with conventional identifier
    # characters to form new identifiers. The only exclusions to this are
    and, or, not, in # they can be used in conventional identifiers
    # special operators are to be infixed without the dot notation.

    # indefinite characters
    # these characters can only be used with other special characters of
    # the same set to create new special identifier.
    = + - * / ^ √ & | > < =(special_chars)

    # definite characters
    # these group of characters cannot be overloaded as is, but can be combined
    # to form new identifiers.
    (special_chars)= :: <: >: >> << . ~ => !

    # language-level characters
    # this group of characters cannot be overloaded nor can they be combined
    # with other special characters to form new characters.
    -> , . $ \\

    # reserved operstors
    \ = prefix
    | = prefix and postfix
    / = prefix and postfix

    # you can call an operator like a function
    println (+ 56, 5)
    println +(56, 5)

    @operator 40, "left", "infix":
    #:: Rango, List{$A[Rango.T]}
    fun = rango, list:
        rango.populate = list
    var x = Rango = [1, 2, 3, 4]

    # identifier characters can be used as operators must be surrounded by spaces.
    @operator 20:
    fun ϵ(a, b):
        a in b

    if a ϵ b: println "Booyah!"

    call.() # callable
    getIndex.() # indexable

    let greet, list = Greeter(), MyList(1, 2, 3)
    greet('Banji')
    list[3]

TRY, CATCH & ENSURE
    if numerator and denominator == 0:
        raise DomainError.() # raising an exception.

    process(bigData)
    catch _ divError: #:: DivByZeroError
        println self.msg
    ensure: # a catch can be accompanied by an ensure block.
        rollBack(bigData)

    # explicit catch function call
    f ->open('banana.png')`ferr->write('Hello')
    catch ferr fnfe: #:: FileNotFoundError
        println self.msg

    # error coalescing
    memory[name]`{0} # catch all
    memory[name]`{KeyNotFoundError|NoValueError: 0} # catch specific exceptions

    # managed resource
    try let f = open '/sdcard/db.sql':
        f.write data 

    # the normal try catch is supported
    try:
        f.open 'banana.png'
    catch _ err: #: FileNotFoundError
        print self.msg


MACROS # NEEDS REVIEW !!!!!!!
    # Dexter macros are resolved at parse time.
    # rather than using the AST, Dexter macros work on parse tree.
    #:: BinaryExpression
    macro reverseExpression binExpr:
        return binExpr->rhs, ->op, ->lhs

    var half = @reverseExpression 2 / 4

    macro assert cond = IfExpression:
        let line = cond.lineNumber
        return
        <
            if !<cond>:
                println 'assertion [<cond>] failed on line <line>'
        >
    ..

    @assert num and den != 0

    macro class
        params = ParamExpr,
        iden = Identifier,
        colon = <:>?,
        body = TypeBody? # the '?' means optional
    :
        if body and colon != nil:
            return <type>, iden, params
        return <type>, iden, params, colon, body
    ..

    @class Person name, age:
        let name, age = Str, Int

OTHER LITERALS # @INC
    let fraction = 3//2 # rational numbers.

    var complex = 1 - 1im # complex numbers.

    var regex = /\d+(.\d+)?/ # regex.

    var block_regex = ///^ (
      ?: [-=]>
       | [-+*/%<>&|^!?=]=
       | >>>=?
       | \.{2,3}
    )
    ///

    # non-standard literals
    var ns_number = 345_NGN
    var ns_str = ns_'1, 2, 3, 4'
    var ns_list = ns_[1, 2, 3, 5]
    var ns_dict = ns_[name: 'Steve', age: 24]
    let ns_tuple = ns_(name: 'Steve')

    # builtin non-standard literals
    var raw_string = r_"\t represnts a tab character"

BUFFER TYPE
    # buffer is a base array that types like List, Str, Chars use to build their internal
    # array structure.
    let int5 = Buffer{Int}(5)
    # You can resize and also fill a buffer.
    let buffer = Buffer{Int}(10, 10).fill(0)
    buffer ->resize(1, 20) ->fill(0, $0)

BASIC ARITHMETIC OPERATIONS
    let t = 2 + 2
    let u = 5f * 20d
    var v = 5 / 2 # this returns an F64 even though the operands are Ints
    var w = 5 ~/ 2 # this returns a clamped Int result of the above
    var x = 6 % 5
    let y = 5i16 ^ 2_i8
    let z = I8(√25)

INTEGER BITWISE FUNCTIONS
    var x = 2 .bitand 5 # and
    var y = 3 .bitor 6 # or
    var z = 6 .bitnot # not
    var a = 7 .bitxor # exclusive or
    var b = a .bitshl b # bit shift left
    var c = b .bitshr a # bit shift right

PREDEFINED TYPE HIERARCHY
    Any
        Type
        Func
        Indie
            Real
                Integer
                    Signed
                        Int, I8, I16, I32, I64,
                    Unsigned
                        UInt, U8, U16, U32, U64
                Float
                    F32, F64
            Complex
                Cmp64, Cmp128
            Bool
        Array
            Buffer
            List
                AbStr
                    Str, Chars
                Range
                Indexer
            Tuple
                Name Tuple
        Generator

POSSIBLE COMPILER DEPENDENCIES
- libffi    (foreign function interface)
- gmp       (bignum)
- libprce   (regex)
# - libmill   (goroutines)

# END
