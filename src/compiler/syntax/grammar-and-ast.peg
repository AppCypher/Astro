eoi =
  | !.

digitbinary =
  | [0-1]

digitoctal =
  | [0-7]

digitdecimal =
  | [0-9]

digithexadecimal =
  | [0-9a-fA-F]

integerbinaryliteral =
  | '0b' digitbinary ('_'? digitbinary)*
  { type, value }

integeroctalliteral  =
  | '0o' digitoctal ('_'? digitoctal)*
  { type, value }

integerhexadecimalliteral  =
  | '0x' digithexadecimal ('_'? digithexadecimal)*
  { type, value }

integerdecimalliteral  =
  | digitdecimal ('_'? digitdecimal)*
  { type, value }

integerliteral =
  | integerbinaryliteral
  | integeroctalliteral
  | integerhexadecimalliteral
  | integerdecimalliteral // Can eat others cake
  { type, value }

floatbinaryliteral  =
  | '0b' digitbinary ('_'? digitbinary)* '.' digitbinary ('_'? digitbinary)* ('e' [-+]? digitbinary ('_'? digitbinary)*)?
  | '0b' digitbinary ('_'? digitbinary)* 'e' [-+]? digitbinary ('_'? digitbinary)*
  { type, value }

floatoctalliteral  =
  | '0o' digitoctal ('_'? digitoctal)* '.' digitoctal ('_'? digitoctal)* ('e' [-+]? digitoctal ('_'? digitoctal)*)?
  | '0o' digitoctal ('_'? digitoctal)* 'e' [-+]? digitoctal ('_'? digitoctal)*
  { type, value }

floathexadecimalliteral  =
  | '0x' digithexadecimal ('_'? digithexadecimal)* '.' digithexadecimal ('_'? digithexadecimal)* ('p' [-+]? digithexadecimal ('_'? digithexadecimal)*)?
  | '0x' digithexadecimal ('_'? digithexadecimal)* 'p' [-+]? digithexadecimal ('_'? digithexadecimal)*
  { type, value }

floatdecimalliteral  =
  | (digitdecimal ('_'? digitdecimal)*)? '.' digitdecimal ('_'? digitdecimal)* ('e' [-+]? digitdecimal ('_'? digitdecimal)*)?
  | digitdecimal ('_'? digitdecimal)* 'e' [-+]? digitdecimal ('_'? digitdecimal)*
  { type, value }

floatliteral =
  | floatbinaryliteral
  | floatoctalliteral
  | floathexadecimalliteral
  | floatdecimalliteral // Can eat others cake
  { type, value }

numericliteral =
  | floatliteral
  | integerliteral  // Can eat others cake
  { type, value }

coefficientexpression = // Unfurl
  | floatbinaryliteral identifier
  | floatoctalliteral identifier
  | floatdecimalliteral identifier
  | integerbinaryliteral identifier
  | integeroctalliteral identifier
  | !('0b' | '0o' | '0x') integerdecimalliteral identifier // Accepts others failed cake, e.g. will parse 0b01 as '0' and 'b01'. Rectified with predicate.
  { type, coefficient, identifier }

noname =
  | '_'

identifierbeginchar =
  | [a-zA-Z_] // TODO

identifierendchar =
  | identifierbeginchar
  | digit

identifier =
  | identifierbeginchar identifierendchar*
  { type, name }

operatorchar =
  | [+\-*/\\^%!><=÷×≠≈¹²³√]// TODO

operator =
  | (!(regexliteral) operatorchar)+ // Must not consume regexliteral
  { type, name }

pathnamechar =
  | identifierendchar | [\-] // TODO

charsnonewlineorsinglequote =
  | (!(newline | "'") .)+ // TODO
  { token }

charsnonewlineordoublequote =
  | (!(newline | '"') .)+ // TODO
  { token }

charsnonewlineortriplesinglequote =
  | (!(newline | "'''") .)+ // TODO
  { token }

charsnonewlineortripledoublequote =
  | (!(newline | '"""') .)+ // TODO
  { token }

charsnohashequal =
  | (!('#=' | '=#') .)+ // TODO
  { token }

charsnonewline =
  | (!(newline) .)+ // TODO
  { token }

charsnonewlineorforwardslash =
  | (!(newline | '/') .)+ // TODO
  { token }

space =
  | [ \t]

nameseparator =
  | !(identifier | numericliteral) _?

indent = // TODO. adding !space
  | ' '+
  { level }

samedent = // TODO. adding !space
  | ' '+
  | ''
  { level }

dedent = // TODO. adding !space
  | ' '+
  { level }

newline =
  | '\r'? '\n'

nextline =
  | newline (_? newline)*

singlelinecomment =
  | "#" charsnonewline? &(newline | eoi)
  { type, token }

innermultilinecomment =
  | "#=" charsnohashequal? (innermultilinecomment charsnohashequal?)* '=#'
  { type, token }

multilinecomment =
  | "#=" charsnohashequal? (innermultilinecomment charsnohashequal?)* '=#' _? &(newline | eoi)
  { type, token }

comment =
  | multilinecomment
  | !('#=') singlelinecomment // Accepts others failed cake. Rectified with predicate.

nextcodeline =
  | space* nextline (samedent comment (nextline | &eoi))*
  { comments }

dedentoreoiend =
  | nextcodeline dedent
  | nextcodeline? _? &eoi
  { comments }

linecontinuation =
  | space* '...' space* nextline samedent

spaces =
  | space+

_ =
  | linecontinuation
  | &{ignorenewline} nextcodeline samedent
  | space+ // Can eat others cake

booleanliteral =
  | 'true'
  | 'false'
  { type, value }

singlelinestringliteral =
  | "'" charsnonewlineorsinglequote? "'"
  | '"' charsnonewlineordoublequote? '"'
  { type, token }

multilinestringliteral =
  | "'''" charsnonewlineortriplesinglequote? (nextline samedent charsnonewlineortriplesinglequote?)* "'''"
  | '"""' charsnonewlineortripledoublequote? (nextline samedent charsnonewlineortripledoublequote?)* '"""'
  { type, token }

stringliteral =
  | multilinestringliteral
  | singlelinestringliteral // Can eat others cake
  { type, token }

regexliteral =
  | '/' charsnonewlineorforwardslash? '/'
  { type, token }

_comma =
  | _? ','

listarguments =
  | primitiveexpression (_comma _? primitiveexpression)* _comma?
  { expressions }

listargumentsmultiple =
  | listliteral (nextcodeline samedent listliteral)+
  | listarguments (_? ';' _? listarguments)+ (_? ';')?
  | listarguments (_? ';')?
  { expressions }

listliteral =
  | '[' _? ']' // ignorenewline
  | '[' spaces? listargumentsmultiple _? ']' // ignorenewline
  | '[' nextcodeline indent listargumentsmultiple nextcodeline dedent ']'
  { type, expressions }

objectargument =
  | identifier _? ':' _? objectblock &(primitiveexpression | '}')
  | identifier _? ':' _? primitiveexpression &(_comma | nextcodeline _? | _? '}')
  | identifier &(_comma | nextcodeline _? | _? '}')
  { key, value }

objectblock =
  | nextcodeline indent objectarguments nextcodeline dedent
  { type, expressions: [{ key, value }] }

objectliteral =
  | '{' _? '}' // ignorenewline
  | '{' spaces? objectarguments _? '}' // ignorenewline
  | '{' nextcodeline indent objectarguments nextcodeline dedent '}'
  { type, expressions: [{ key, value }] }

dictargument =
  | primitiveexpression _? ':' _? objectblock &(primitiveexpression | '}')
  | primitiveexpression _? ':' _? (subdictliteral | primitiveexpression) &(_comma | nextcodeline _? | _? '}')
  | identifier &(_comma | nextcodeline _? | _? '}')
  { key, value }

dictarguments =
  | dictargument ((_comma _? | nextcodeline samedent)? dictargument)* _comma?
  { expressions: [{ key, value }] }

dictliteral =
  | '@' '{' _? '}' // ignorenewline
  | '@' '{' spaces? dictarguments _? '}' // ignorenewline
  | '@' '{' nextcodeline indent dictarguments nextcodeline dedent '}'
  { type, expressions: [{ key, value }] }

setarguments =
  | primitiveexpression (_comma _? primitiveexpression)* _comma?
  { expressions }

setliteral =
  | '%' '{' _? '}' // ignorenewline
  | '%' '{' spaces? setarguments _? '}' // ignorenewline
  | '%' '{' nextcodeline indent setarguments nextcodeline dedent '}'
  { type, expressions }

tuplearguments =
  | primitiveexpression (_comma _? primitiveexpression)+ _comma?
  | primitiveexpression _comma
  { expressions }

tupleliteral =
  | '(' _? ')' // ignorenewline
  | '(' spaces? tuplearguments _? ')' // ignorenewline
  | '(' nextcodeline indent tuplearguments nextcodeline dedent ')'
  { type, expressions }

namedtuplearguments =
  | identifier _? ':' _? primitiveexpression (_comma _? identifier _? ':' _? primitiveexpression)* _comma?
  { expressions: [{ key, value }] }

namedtupleliteral =
  | '(' _? ':' _?  ')' // ignorenewline
  | '(' spaces? namedtuplearguments _? ')' // ignorenewline
  | '(' nextcodeline indent namedtuplearguments nextcodeline dedent ')'
  { type, expressions: [{ key, value }] }

symbolliteral =
  | '$' identifier
  | '$' '(' _? expression _? ')' // ignorenewline
  | '$' '(' block ')'
  { type, expressions }

listcomprehension =
  | '[' _? primitiveexpression _? '|' _? forhead (_? ';' _? forhead)* (_ 'where' _ primitiveexpression)? _? ']' // ignorenewline
  { type, expression, iterators:[{ lhs, rhs}], guard }

dictcomprehension =
  | '@' '{' _? (primitiveexpression _? ':' _? primitiveexpression | identifier) _? '|' _? forhead (_? ';' _? forhead)* (_ 'where' _ primitiveexpression)? _? '}' // ignorenewline
  { type, key, value, iterators:[{ lhs, rhs}], guard }

setcomprehension =
  | '%' '{' _? primitiveexpression _? '|' _? forhead (_? ';' _? forhead)* (_ 'where' _ primitiveexpression)? _? '}' // ignorenewline
  { type, key, value, iterators:[{ lhs, rhs}], guard }

comprehension =
  | listcomprehension
  | dictcomprehension

literal =
  | numericliteral
  | booleanliteral
  | stringliteral
  | regexliteral
  | listliteral
  | objectliteral
  | dictliteral
  | setliteral
  | tupleliteral
  | namedtupleliteral
  | symbolliteral
  | comprehension

callarguments =
  | (identifier _? ':' _?)? primitiveexpression (_comma _? (identifier _? ':' _?)? primitiveexpression)* _comma?
  { expressions: [{ key, value }] }

callpostfix =
  | spaces? ('!' spaces?)? '.'? '(' _? ')' // ignorenewline
  | spaces? ('!' spaces?)? '.'? '(' spaces? callarguments _? ')' // ignorenewline
  | spaces? ('!' spaces?)? '.'? '(' nextcodeline indent callarguments nextcodeline dedent ')'
  { type, expression, mutative, vectorized, arguments: [{ key, value }] }

dotnotationpostfix =
  | spaces? '.' identifier
  { type, expression, field }

cascadenotationargument =
  | (callpostfix | indexpostfix | spaces? '.' identifier) (spaces? '?')? (subatompostfix (spaces? '?')?)*

cascadenotationarguments =
  | cascadenotationargument (_comma _? cascadenotationargument)+ _comma?
  | cascadenotationargument _ ('.'? operator | keywordoperator) _ (cascadenotationarguments | cascadenotationargument)

cascadenotationpostfix = // Unfurl
  | spaces? '.' '{' spaces? cascadenotationarguments _? '}' // ignorenewline
  | spaces? '.' '{' nextcodeline indent cascadenotationarguments nextcodeline dedent '}'
  { type, expression, cascadeaccess }

indexargument =
  | (primitiveexpression _?)? ':' (_? primitiveexpression? _? ':')? _? primitiveexpression?
  | primitiveexpression
  { index, begin, step, end }

indexarguments =
  | indexargument (_comma _? indexargument)* _comma?
  { expressions: [{ index, begin, step, end }] }

indexpostfix =
  | spaces? '[' spaces? indexarguments _? ']' // ignorenewline
  | spaces? '[' nextcodeline indent indexarguments nextcodeline dedent ']'
  { type, expression, arguments: [{ key, value }] }

ternaryoperator =
  | '(' spaces? primitiveexpression _? ')' _? '?' _? primitiveexpression _? ':' _? primitiveexpression  // ignorenewline
  | '(' nextcodeline indent primitiveexpression nextcodeline dedent ')' _? '?' _? primitiveexpression _? ':' _? primitiveexpression
  { type, condition, truebody, falsebody }

return =
  | 'return' (nameseparator expressionnocontrolptimitive)?
  { type, expression }

yield =
  | 'yield' ((_ 'from')? nameseparator expressionnocontrolptimitive)?
  { type, expression, redirect }

raise =
  | 'raise' (nameseparator expressionnocontrolptimitive)?
  { type, expression }

continue =
  | 'continue' (_? '@' identifier)?
  { type, label }

break =
  | 'break' (nameseparator expressionnocontrolptimitive)?  (_? '@' identifier)?
  { type, expression, label }

spill =
  | 'spill' (_? '@' identifier)?
  { type, label }

controlprimitive =
  | return
  | yield
  | continue
  | break
  | raise
  | spill

subatompostfix =
  | callpostfix
  | dotnotationpostfix
  | cascadenotationpostfix
  | indexpostfix

subatom =
  | '(' spaces? simpleexpression _? ')' identifier? // ignorenewline
  | '(' nextcodeline indent simpleexpression nextcodeline dedent ')' identifier?
  | coefficientexpression
  | literal
  | noname
  | identifier
  | operator

atom =
  | subatom (spaces? '?')? (subatompostfix (spaces? '?')?)*
  { type, expression }

prefixatom =
  | operator atom

postfixatom =
  | atom '.'? operator

prepostfixatom =
  | prefixatom
  | postfixatom
  | atom

keywordoperator =
  | 'is' _ 'not'
  | 'in'
  | 'not' _ 'in'
  | 'mod'
  | 'is'
  { type, name }

infixexpression =
  | (prefixatom | atom) '.'? operator infixexpression
  | prepostfixatom _ ('.'? operator | keywordoperator) _ infixexpression
  | prepostfixatom
  { type, expressions, operators }

range =
  | (infixexpression _?)? '..' (_? infixexpression _? '..')? _? infixexpression
  { type, begin, step, end }

commandnotationrest =
  | spaces &(identifier | stringliteral | numericliteral | range | symbolliteral)  primitiveexpression
  | spaces? lambdaexpression
  { arguments: [{ key, value }] }

commandnotation =
  | !(operator) atom (spaces? '?')? (spaces? '!')? commandnotationrest
  { type, expression, mutative, arguments: [{ key, value }] }

primitiveexpression =
  | range
  | infixexpression
  | commandnotation

simpleexpression =
  | ternaryoperator
  | primitiveexpression

tupleexpression =
  | simpleexpression (_comma _? simpleexpression)* _comma?
  { type, expressions }

dotnotationline =
  | dotnotationpostfix (spaces? '?')? (subatompostfix (spaces? '?')?)*

dotnotationblock =
  | simpleexpression nextcodeline indent dotnotationline (nextcodeline samedent dotnotationline) (nextcodeline dedent | eoi)

subexpression =
  | dotnotationblock
  | declaration
  | conditionalexpression
  | controlprimitive
  | tupleexpression

expression =
  | subexpression (_? ';' _? expression)* (_? ';')?

// Used in control primitives.
// makes `return exp, exp` possible
// but not `return return exp`
// and not `yield break exp`
subexpressionnocontrolptimitive =
  | declaration
  | conditionalexpression
  | tupleexpression

expressionnocontrolptimitive =
  | subexpressionnocontrolptimitive (_? ';' _? expressionnocontrolptimitive)* (_? ';')?

// Used in declarations and condiational expressions.
// makes `if ... : if ... : exp` possible
subexpressionnoblock =
  | tupleexpression
  | controlprimitive

expressionnoblock =
  | subexpressionnoblock (_? ';' _? expressionnoblock)* (_? ';')?

// Used in declarations and conditional expressions.
// makes `if ... : if ... : block` possible
// also makes `if ... : if ... : exp` possible
// also makes `if ... : exp else: exp` possible
// but not `if ... : if ... : exp else: exp`
// and not `if ... : if ... : exp for ... : exp`
// and not `if ... : if ... : exp else: exp else: exp`
// and not `if ... : for ... : exp else: exp`
subexpressiononeinlinenest =
  | declarationoneinlinenest
  | conditionalexpressiononeinlinenest
  | controlprimitive
  | tupleexpression

expressiononeinlinenest =
  | subexpressiononeinlinenest (_? ';' _? expressiononeinlinenest)* (_? ';')?

block =
  | nextcodeline indent expression (nextcodeline samedent expression)* dedentoreoiend

lhsargument =
  | lhsname (_comma _? lhsname)* _comma?

lhspattern =
  | '(' spaces? lhsname (_comma _? lhsname)* _comma? _? ')' // ignorenewline
  | '(' nextcodeline indent  lhsname (_comma _? lhsname)* _comma? nextcodeline dedent ')'
  | '[' spaces? lhsname (_comma _? lhsname)* _comma? _? ']' // ignorenewline
  | '[' nextcodeline indent  lhsname (_comma _? lhsname)* _comma? nextcodeline dedent ']'
  | '{' spaces? lhsname (_comma _? lhsname)* _comma? _? '}' // ignorenewline
  | '{' nextcodeline indent lhsname (_comma _? lhsname)* _comma? nextcodeline dedent '}'
  |  lhsname (_comma _? lhsname)*

lhsname
  | noname
  | identifier
  | '...' identifier?

ifhead =
  | primitiveexpression (_ 'where' _ primitiveexpression)?
  | subjectdeclaration (_ 'where' _ primitiveexpression)?

elifexpression =
  | 'elif' namesparator ifhead _? ':' _? expressiononeinlinenest
  | 'elif' namesparator ifhead _? ':' block

elseexpression =
  | 'else' _? ':' _? expressiononeinlinenest
  | 'else' _? ':' block

ifexpression =
  | 'if' namesparator ifhead _? ':' _? expressiononeinlinenest (_? elifexpression)* (_? elseexpression)?
  | 'if' namesparator ifhead _? ':' block (_? elifexpression)* (_? elseexpression)?

ifexpressiononeinlinenest =
  | 'if' namesparator ifhead _? ':' _? expressionnoblock
  | 'if' namesparator ifhead _? ':' block

whileexpression =
  | 'while' namesparator ifhead _? ':' _? expressiononeinlinenest (_? endexpression)?
  | 'while' namesparator ifhead _? ':' block endexpression?

whileexpressiononeinlinenest =
  | 'while' namesparator ifhead _? ':' _? expressionnoblock
  | 'while' namesparator ifhead _? ':' block

dowhileexpression =
  | 'do' _? ':'  _? expressiononeinlinenest _? 'while' namesparator ifhead _?
  | 'do' _? ':' block 'while' namesparator ifhead _?

loopexpression =
  | 'loop' _? ':' _? expressiononeinlinenest (_? endexpression)?
  | 'loop' _? ':' block endexpression?

loopexpressiononeinlinenest =
  | 'loop' _? ':' _? expressionnoblock
  | 'loop' _? ':' block

endexpression =
  | 'end' _? ':' _? expressiononeinlinenest
  | 'end' _? ':' block

forhead =
  | 'var'? lhspattern _ 'in' _ primitiveexpression (_ 'where' _ primitiveexpression)?

forexpression =
  | 'for' namesparator forhead _? ':' _? expressiononeinlinenest (_? endexpression)?
  | 'for' namesparator forhead _? ':' block endexpression?

forexpressiononeinlinenest =
  | 'for' namesparator forhead _? ':' _? expressionnoblock
  | 'for' namesparator forhead _? ':' block

ensureexpression =
  | 'ensure' _? ':' _? expressiononeinlinenest
  | 'ensure' _? ':' block

exceptexpression =
  | 'except' _ identifier _? ':' _? expressiononeinlinenest
  | 'except' _ identifier _? ':' block

tryexpression =
  | 'try' _? ':' _? expressiononeinlinenest (_? exceptexpression)+ (_? ensureexpression)?
  | 'try' _? ':' block (_? exceptexpression)+ (_? ensureexpression)?
  | 'try' 'var'? namesparator lhspattern (_ '=' _ primitiveexpression | '=' !(operator) primitiveexpression) ':' _? expressiononeinlinenest (_? exceptexpression)+ (_? ensureexpression)?
  | 'try' 'var'? namesparator lhspattern (_ '=' _ primitiveexpression | '=' !(operator) primitiveexpression) ':' block (_? exceptexpression)+ (_? ensureexpression)?

matchpattern =
  | (identifier _?)? '(' spaces? matchatom (_comma _? matchatom)* _comma? _? ')' // ignorenewline
  | (identifier _?)? '(' nextcodeline indent  matchatom (_comma _? matchatom)* _comma? nextcodeline dedent ')'
  | '[' spaces? matchatom (_comma _? matchatom)* _comma? _? ']' // ignorenewline
  | '[' nextcodeline indent  matchatom (_comma _? matchatom)* _comma? nextcodeline dedent ']'
  | '{' spaces? matchatom (_comma _? matchatom)* _comma? _? '}' // ignorenewline
  | '{' nextcodeline indent matchatom (_comma _? matchatom)* _comma? nextcodeline dedent '}'
  |  matchatom (_comma _? matchatom)*

matchatom
  | primitiveexpression
  | noname
  | identifier
  | '...' identifier?

matchsingleexpression =
  | ('|' | '!') _? matchpattern _? '=>' _? expressiononeinlinenest
  | ('|' | '!') _? matchpattern _? '=>' block

matchexpression =
  | primitiveexpression? (_? matchsingleexpression)+
  | primitiveexpression? (nextcodeline samedent matchsingleexpression)+

matchexpressiononeinlinenest =
  | primitiveexpression? _? ('|' | '!') _? matchpattern _? '=>' _? expressionnoblock
  | primitiveexpression? _? ('|' | '!') _? matchpattern _? '=>' block

iifexpression =
  | callpostfix _? '=>' _? expressiononeinlinenest
  | callpostfix _? '=>' block

iifexpression =
  | callpostfix _? '=>' _? expressiononeinlinenest
  | callpostfix _? '=>' block

iifeexpressiononeinlinenest =
  | callpostfix _? '=>' _? expressionnoblock

lambdaexpression =
  | '|' _? functionparameters _comma? _? '|' _? '=>' _? expressiononeinlinenest
  | '|' _? functionparameters _comma? _? '|' _? '=>' block

lambdaexpressiononeinlinenest =
  | '|' _? functionparameters _comma? _? '|' _? '=>' _? expressionnoblock
  | '|' _? functionparameters _comma? _? '|' _? '=>' block

importpathname =
  | pathnamechar+
  | '..'
  | '.'

importpath =
  | ('/' _?)? importpathname (_? '/' _? importpathname)*
  | stringliteral

importdeclaration =
  | 'import' (_ identifier _? ':') _ importpath  '{' (_? identifier _? ':')? _? (identifier | operator) (_comma (_? identifier _? ':')? _? (identifier | operator) )* _comma? _? '}' // ignorenewline
  | 'import' (_ identifier _? ':') _ importpath  '{' nextcodeline indent (identifier _? ':' _?)? (identifier | operator) (nextcodeline samedent (identifier _? ':' _?)? (identifier | operator)) _comma? nextcodeline dedent '}'
  | 'import' (_ identifier _? ':') _ importpath

exportdeclaration =
  | 'export' _? '{' _? (identifier | operator) (_comma _? (identifier | operator))* _comma? _? '}' // ignorenewline

conditionalexpression =
  | matchexpression
  | ifexpression
  | whileexpression
  | dowhileexpression
  | loopexpression
  | forexpression
  | tryexpression

conditionalexpressiononeinlinenest =
  | matchexpressiononeinlinenest
  | ifexpressiononeinlinenest
  | whileexpressiononeinlinenest
  | loopexpressiononeinlinenest
  | forexpressiononeinlinenest

declaration =
  | iifeexpression
  | lambdaexpression
  | subjectdeclaration
  | functiondeclaration
  | typedeclaration
  | abstdeclaration
  | importdeclaration
  | exportdeclaration

declarationoneinlinenest =
  | iifeexpressiononeinlinenest
  | lambdaexpressiononeinlinenest
  | subjectdeclarationoneinlinenest
  | functiondeclarationonrinlinenest
  | typedeclarationoneinlinenest
  | abstdeclarationoneinlinenest

typehead =
  | ('type' | 'abst') _ identifier

subtype =
  | identifier (_? '(' spaces? functionparameters _? ')')? // ignorenewline
  | identifier (_? '(' nextcodeline indent functionparameters nextcodeline dedent ')')?

typebody =
  | subjectdeclaration
  | '|'? _? subtype (_? '|' subtype)*

typebodyoneinlinenest =
  | subjectdeclarationoneinlinenest
  | '|'? _? subtype (_? '|' subtype)*

names =
  | identifier (_comma _? identifier)*
  { names }

typeblock =
  | nextcodeline indent typebody (nextcodeline samedent typebody)* dedentoreoiend

typedeclaration =
  | typehead _? '(' spaces? parameters _?')' (_? '<:' _? names)?// ignorenewline
  | typehead _? '(' nextcodeline indent parameters nextcodeline dedent ')' (_? '<:' _? names)?
  | typehead (_ '=' _ | '=' !operator | _? ':' _?) typebodyoneinlinenest
  | typehead (_ '=' _ | '=' !operator) nextcodeline indent typebody dedentoreoiend
  | typehead _? ':' typeblock
  { type, name, supertypes, body }

typedeclarationoneinlinenest =
  | typehead (_ '=' _ | '=' !operator | _? ':' _?) expressionnoblock
  | typehead (_ '=' _ | '=' !operator) nextcodeline indent expression dedentoreoiend
  | typehead _? ':' block
  { type, name, supertypes, body }

functionparameters =
  | functionparameter (_comma _? functionparameter)* _comma?

functionparameter =
  | identifier ('.' lhspattern?)? _? ':' _? primitiveexpression
  | lhspattern
  | identifier

functionhead =
  | 'fun' _ (identifier | operator) _? '(' spaces? functionparameters _?')' // ignorenewline
  | 'fun' _ (identifier | operator) _? '(' nextcodeline indent functionparameters nextcodeline dedent ')'

functiondeclaration =
  | functionhead (_ '=' _ | '=' !operator | _? ':' _?) expressiononeinlinenest
  | functionhead (_ '=' _ | '=' !operator) nextcodeline indent expression dedentoreoiend
  | functionhead _? ':' block
  { type, name, parameters: [{ mutable, alias, lhs, value }], body }

functiondeclarationoneinlinenest =
  | functionhead (_ '=' _ | '=' !operator | _? ':' _?) expressionnoblock
  | functionhead (_ '=' _ | '=' !operator) nextcodeline indent expression dedentoreoiend
  | functionhead _? ':' block
  { type, name, parameters: [{ mutable, alias, lhs, value }], body }

subjecthead =
  | ('let' | 'var') nameseparator lhspattern
  | ('let' | 'var') nameseparator identifier (_ identifier)+

subjectdeclaration =
  | subjecthead (_ '=' _ | '=' !operator) expressiononeinlinenest
  | subjecthead (_ '=' _ | '=' !operator) nextcodeline indent expression dedentoreoiend
  { type, mutable, name }
  { type, lhs, rhs }

subjectdeclarationoneinlinenest =
  | subjecthead (_ '=' _ | '=' !operator) expressionnoblock
  | subjecthead (_ '=' _ | '=' !operator) nextcodeline indent expression dedentoreoiend
  { type, mutable, name }
  { type, lhs, rhs }

program =
  | (comment? nextcodeline)? (samedent expression (nextcodeline eoi? | _? eoi))+
  | (comment? nextcodeline? eoi)?
