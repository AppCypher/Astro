# BEGIN
# 29/05/17
# Astro 0.1.0
# Back to Brackets 

SINGLE-LINE COMMENTS
    # Hello, World!

MULTILINE COMMENTS
    #=
        I’m Dexter.
        #=
            Yay, nested comments!
        =#
        And I Rock.
    =#

SUBJECT DECLARATION & DEFINITION
    var a # unitialized subject declaration.
    var b = 25 = 50
    let c = 8

    # var is used for subjects whose values can change.
    # let is used for subjects whose values cannot change.

    let b = 5 # covariant subject declaration.
    let d # uninitialized subject declaration.

    var Ω = 5, δ = 6 # multiple subject definition.
    let x, y, z

IDENTIFIERS
    # name of subjects must always start with a character and
    # can be followed with characters, digits or underscore.
    var name
    fun show99BottlesOfBeer():
        println lyrics

    # by convention, names use camel case style
    fun createMeme():
        println(memes[rand])

    # by convention, subject and function names start with a lowercase character
    # by convention, type names start with an uppercase character.
    type Cat:
        let name, tag

ASSIGNMENT
    let one, two = 1, 2 # one = 1, two = 2

    let (pi, π) = 3.141 # pi = 3.141, π = 3.141

    let (one, two) = (1, 2) # one = (1, 2), two = (1, 2)

CONSTANTS
    let b # deferred constant initialization
    b = 56

    let d = Int() # d == 0
    d = 10 # error!

FUNCTION DEFINITION (1)

    fun add(a, b): # parameters are immutable by default
        return a + b

    var sum = add(25, 52)

    fun echo(value):
        print(value)
        return value 
        
    echo value # if a function takes one argument, the brackets can be ommitted
    # there's one catch. the argument must be a string literal, a number literal, 
    # a boolean literal or an identifier for it to work. (BINS)
    # it won't work with complex expressions or named arguments.

    echo [1] # will evaluate as echo[1] not echo([1])
    echo +5 # will evaluate as echo + 5 not echo(+5)

    fun mul(!a, !b): # the bang character signifies mutability
        return a * b

    # you can annotate the argument and return types of a function
    #: Int, Int -> Int
    fun mod(a, b):
        return a % b


EXPRESSION-ORIENTED
    var isNyproCrazy = faveHobby == 'CountingBirds' # returns true or false to isNyproCrazy

    fun add(a, b):
        a + b # 'return' is not needed here. result of a + b will be returned to the caller.
    ..
    nypro.hieght = add(aditya.height, tripleo.height)

    # a semi-colon at the end of a block, stops it from returning its evaluated
    # result
    fun setName(p, name):#:: Person, Str
        p.name = name;
    ..

    let name = setName('John Smith') # error! setName returns no result.

SPECIFYING TYPES
    var number = 5
    var todo = Str('Create a programming language')

    var address = 506 # initialization
    let job = Str() # default costruction.

    var identifier #: Str|Int # optional type specification.

SOME BUILT-IN TYPES
    var index = UInt(2_000) # UInt represents unsigned integer; no negative values.

    var debt = Int(-100) # Int represents signed integer; you can have negative values.

    let e = F64(2.718281828459045)
    let dogBreed = Str('German Shepherd') # Str represents immutable UTF-8 string.

    var laptop = Chars('Alienware M18') # Chars represents mutable UTF-32 string.

    var listOfGroceries = ['Oranges', 'Cabbages', 'Tomatos', 'Bananas'] # this is a list.

    var game, year = 'BioShock Infinite', 2014 # this is a tuple.

VALUES & REFERENCES
    # by default primitive objects (UInt, Int, Float, Bool) are passed around by value and
    # by default complex objects (Str, user-defined types) are passed around by reference.
    var number = 502
    var account = getAccount('Dumbledore')

    # however, you can change this behavior with 'ref' and 'val'.
    var newAccount = val account # passing a complex object by value.
    var pointer = ref number # passing a primitive object by reference.

    # Dexter uses compile-time reference counting to manage memory, unlike Python or
    # Javascript which use runtime tracing GC.
    # It also does reference cycle breaking at compile-time. :)
    myCompany.affiliate = ref yourCompany
    yourCompany.affiliate = ref myCompany

    let myAccount = iso Account('Nypro')
    # iso means only the subject can hold a reference to the object.

    let trooperClone = acq trooper # acq is shallow copy operation.

    let player = team.player

    # you can specify a subject reference beforehand
    let library = acq

    fun getAmount():
        return let amount # passed by reference, but it cannot be written to.

    fun swap(a, b): #: ref, ref -> _
        a, b = b, a;
    ..

NUMBERS
    var index = 5
    var axis = -3
    let meters = 0.25e-5
    let salary = 10_000f
    var color = 0x6FFF00p+12 # hex
    var opCode = 0b10110001 # bin
    var interest = 0o566768 # oct
    let pi = 3.14bf # BigFloat

ACCESS MODIFIERS # NEEDS REVIEW!!!
    var money = 0 # subjects, functions, types, etc. are public by default.

    fun sub*(a, b): # becomes inaccessible outside module
        a - b

    var pi* =  3.14

    type Person*(!name*, !age*)

BLOCK DECLARATIO
    var 
        title  = "The Drunk Chef Visits Chicken Town"
        author = "appcypher"
        year   = "2028"
    
    type 
        Person(!name, !age)
        Student(!courses, !class)

TUPLES
    var name, age = 'Emeka Okorafor', 27 # this is an open tuple
    # name and age are assigned to 'Emeka Okorafor' and 27 correspondingly.
    
    var game, year = ('Uncharted 4', 2016) # this is a closed tuple
    # game and year are assigned to 'Uncharted 4' and 2016 correspondingly.

    # NOTE: an open tuple is passed by value, a closed tuple is not
    name, age = age, name

    let make, year = car.details()

    let index, car = 15, ('Ferrari', 1995) # car is a tuple.

    let map = () # empty tuple

    # named tuple
    let http200Status = (statusCode: 200, description: 'Ok')

PROPERTIES
    # properties provide getter/setter behavior.
    var name = get: "[firstname] [surname]"
    var age =
        set:
            var extra = 5; 
            age += extra 

        get: age -= 5

LAZY EVALUATION
    # an operation marked lazy will only execute on access of subject, not before
    let appComponent = lazy iso self.getAppComponent()
    var lazyField = lazy
        get: println "I'm lazy!"

LISTS
    var unorderedList = [7, 3, 8, 5, 4, 0, 9, 1, 2, 6]

    var emptyList =  []

    var names = [Str] # list of type specified

    var contestants = [Str]['Steve', 'Aditya', 'Sizwe', 'Pierre']

    # Dexter uses 1-based indexing, so every list indices start at 1.
    var disqualified = contestants[1..4]

    var reversed = contestants[-1..] # -1 is the 1st index from behind, i.e. the last index.

    let myGarage = [Car][('Mustang'), ('Eleanor'), ('Bugatti'), ('Lamborghini')]

    let yearSalary = [Int]{12}[] # you can specify a size for the list.

    yearSalary[1..3] = [2_000, 2_000, 2_500]

    let calendar = {12}[]

    # proposed operations with lists.
    var concatenate = [1, 2] ++ [3] # [1, 2, 3]
    var multiply = [1, 2] ** 2 # [1, 2, 1, 2]
    let subtract = [1, 2, 3, 4, 3] -- [4, 3] # [1, 2]
    let divide = [1, 2, 5, 6, 3, 4] // [5, 6] # [[1, 2], [3, 4]]

MATRICES
    # Dexter lists can be used as matrices
    let a = 2x2 [F64][
        1, 2
        [3, 4, # this line is [3, 4, 5, 6]
        5, 6]
    ]

    var matrix = 2x2 List[Int]([
        1, 0
        0, 1
    ])

    matA[,] = [
        [1, 6, 3]
        [3, 7, 4]
    ]

    let subset = mat4[1:, 1:2]

    # vectorised operations
    var matA = matB *. matC 
    var matD = matA.dot.(matB)

    # Dexter's lists are by default, row-major order, but you can make it
    # column major by using the transpose function
    let y = [1, 2, 3]
    # 1 2 3

    let z = [1, 2, 3]`
    # 1
    # 2
    # 3

    let x = y[:2]`

    # splatting a list
    let a = [
        1, 2
        0, 4
    ]`

    ...a
    # 1 0
    # 2 4

    # splatting a list exposes the content of the matrix as an open tuple
    # splatting a returns a 2-dimensional open tuple.
    let b = [
        ...a`, ...a`
        ...a`, ...a`
    ]
    # 1 0 1 2
    # 2 4 0 4
    # 1 2 1 0
    # 0 4 2 4

DICTIONARIES
    # dictionaries are basically key-value lists.
    let family = {
        'mum':
            'name': 'Esther Williams'
            'age' : 41
        dad: # unquoted keys are taken as strings
            name: 'Sunday Williams'
            age : 46
        sister:
            name: 'Shade Williams'
            age: 15
    }

    let sisterName = family['sister', 'name']

    # to use variables from the outer scope, the variable name needs to be escaped wit `\`
    var professor = {
        \id1: 'Charles Xavier'
        \id2: 56
    }

    let testScores = {
        'class room 1': [0, 15, 30, 15, 76, 50],
        'class room 2': 45, 50, 83, 9, 39, 81
    }
    var class1Scores = testScores['class room 1']

    var contacts = {:} # empty dictionary
    var user = 2x2 Dict[Str, User]()
    var scoreList = Dict[Str, Int]()

OTHER TYPES OF LISTS
    var range = [1:20] # range is a type of list
    var indexer = list[1:] # indexer is a type of list.
    # it holds ref to a subset of another list


PACKING & UNPACKING
    var list = [for x <- [:10]: yield x] # [ ] turns a generator into a list.
    var open = ...list # ... turns a generator, list or closed tuple to an open tuple.
    var closed = (a, b, c) # turn an open tuple to closed tuple

    let primes = [2, 3, 5, 7, 11]
    let numbers = [2, 4, 8, ...primes]

REST
    var a, ...b = 1, 2, 3, 4

    fun sum(a, ...b):
        a + b.foldLeft(0, |x, y| x + y)

RANGED VALUE
    var height = 3d``7d
    height = 6d
    height = 8d # error

    fun isPrime(n = 2``):
        math.isPrime(n)

    isPrime(24)
    isPrime(1) # error

STRINGS
    let language = 'Astro'
    let year = 2015
    var story = "[language] was started in the [year]" # string interpolation.

    let calc = '5 * 50 = [5 * 50]'
    # both single and double quotes can be used to represent a string literal.

    # String formatting
    println("The price is [price.%0.2f]")

    # non-standard string literals preceded by characters are not affected
    # by escape sequences, because they are processed verbatim.
    var verbatimStr = r."Use '\t' to represent tab"

    # here string (DEPRECATED). first and last new lines are always ignored.
    var verbatimStr = '''
    Hello, World!
    '''

    var string = 'Hello' # Str
    var chars = ch.'Hello' # Chars

    # proposed operations with strings.
    var concatenate = 'ab' + 'c' # 'abc'
    var multiply = 'ab' * 2 # 'abcabc'
    let subtract = 'abcac' - 'ca' # 'abc'
    let divide = 'abcdeabc' / 'de' # ['abc', 'abc']
    let escapeSequences = '\t \n \' \" \[ \# \\'

    # multiline string.
    var greeting = 'Hello,'
        'World!'

MULTILINE EXPRESSIONS
    # expressions that spread accross multiple lines must be enclosed in brackets
    # or used with an isolated three dots ending the previous line.
    var zero = -100 ...
    + 100

    if x < y ...
    & a == b:
        doTask

    var languageDesigner =
        "Steve Akinyemi"

    sum 1, 2, 3, 4, 5, 6, 7, 8, ...
    9, 10, 11, 12

BLOCK SCOPE
    # a block represents a scope
    let country = 'India'
    block:
        let country = 'Nigeria'
        println(country) # Nigeria

    println(country) # India

    # multiple statements can be written on one line separated by semi-colons.
    var temp = a ; a = b ; b = temp

    # multiple blocks can also be written on the same line using the '\\' punctuator.
    if studio.isLive: blockAccess \\ else: openAccess

INDENTATION # NEEDS REVIEW!!!!!!
    # Dexter is an indentation-based language
    if x == y:
        if a == b:
            doTask
    # indentation is used here to disambigute if-else association
    else:
        doNothing

    let myName = " Nypro "
        ->trim()
        ->reverse()
        # indented dot/arrow notation links with the argument of the previous  line.
    ->println()

    playMusic(
        'Asa',
        'Jailer',
        '2009'
    ).rewind 2

    var x =
        25 + 6
        # a continued line following an assignemnt operator should be indented


SANDWICHED STATEMENTS
    # you can sandwich multiple expressions where a single expression is expected.
    # by putting them in brackets.
    var faveSoccerClub =
    (team == 'Manchester United' ~ (println('You suck!'); team) : _)

    println('Hello, ', (println('World'); '!'))

IF STATEMENT
    if isAdrianRich:
        spendAll('on parties')

    elif isOroboRich:
        spendAll('on legos')

    elif isSyconRich:
        spendAll('on suits')

    else:
        cry('we are broke')

    if phoneNumber == nil:
        useEmail()

    if let stockCode = getStockCode('APPLE'): # block is evaluated if stockCode is not nil
        println('APPLE: [stockCode]')

    if copy = getCopy():
        println(copy)

    # nested if statements can be written together with their corresponding
    # else statements stacked accordingly
    if tim.age > 16, if car.state == 'good':
        tim.drive(car)
    else:
        raise Error('Driver must over the age of 16')
    else:
        raise Error('Car is in bad state. Repair immediately!')

NIL
    # sometimes, it is important to represent an empty or missing state, this can be
    # achieved in Dexter with optional typing.
    var code #: Str # cannot be nil
    var program = 'println(\"Hello World\")' #: Str|Nil
    var anotherProgram #: Str?

    # a nilable cannot be assigned to a non-nilable subject without a proper nil coalescing with a fallback value.
    var programList = Str()?
    var cartoonList = [Str?]

    # nilable unwrap
    let name = dave?.name

    # exceptionable unwrap
    getAccount("Default")! # if result is nil, raise NilError
    
    # nil coalescing 
    let name = getName() ?? "John Smith"

    var b = "Hello"?
    b? ~ b : 5

    if isRecieving? == true:
        println('boolean value recieved')
    elif isRecieving.nil:
        println('remote server stopped recieving')


CONDITIONS
    # Dexter discourages reptition in conditional expression.
    x < y & y < z # deprecation warning!
    x < y < z

    x == y & y == z # deprecation warning!
    x and y == z # if both x and y equals z.
    x == y == z

    x == y | y < z # deprecation warning!
    x == y or < z # if x equals y and also greater than z.

    x == y & a == b # no warning

    if x != y: println('x does not equal y')
    if x !in list: println('x is not inside list')
    if !x:  println('x is not nil')

    a.trim() == b.trim()
    |a == b|.trim()

    #: Node -> Bool
    fun isSymmetric node:
        node.|right == left|.height

FOR LOOP
    for i <- [1..10]:
        println i

    let interestingNumbers = {
        'prime' : 2, 3, 5, 7, 11, 13
        'square' : 1, 2, 4, 9, 25, 36
        'fibonacci' : 1, 1, 2, 3, 5, 8
    }

    for kind, number <- interestingNumbers: # parallel pairing through a dictionary.
        println '[kind]: [number]'

    # an extra tuple param serves as the iteration index
    for names, index <- register:
        println index, names

    for name, (key, value) <- nameList, table:
        println name, key, value

    # looping through a number
    for num = 50: num

    for up, down <- [1..20], [20..1]: # parallel pairing through ranges.
        println '[up] :: [down]'

    for upper <- [1..20], for lower <- [1..20]: # nested iterations through ranges.
        println '[upper] :: [lower]'

    for i <- [1..20]:
        i += 1 # error! immutable subject.
        j = i
    ..

    for var i <- [1..20]:
        i += 1
        j = i`
    ..

    for _ <- [1..fifty]:
        println('Hello')

LIST COMPREHENSION # NEEDS REVIEW!!!
    var oddList = [for i <- [1..20], where i .mod(2) != 0: yield x]
    var oddList = x << x <- [1..20], x .mod(2) != 0
    fun times(): x * y << x <- [1..10], y <- [20..1], even(y)

BREAK WITH
    for name = register:
        if name == 'Tony':
            break name
        ""

IN
    if student.name in defaulterList:
        println '[student.name] hasn\'t paid yet. Contact parents'

    if 'ps4' !in birthdayPresents:
        println 'Aaargh! Everyone hates me'

    if /dollar[s]?/ in sentence:
        println 'Change occurrences of "Dollar" to "Pound"'

WHERE
    # where is used to establish an extensive condition especially where it is
    # not expected.
    if person in auditionRoster, where person.mark > 40.0:
        acceptanceList.add person

    for book in library, where book.title.contains('adventure'):
        personalLibrary.add book

WHILE LOOP & LOOP
    while file.hasNext():
        println file.next()
    ..
    # loop
    loop: # synonymous with while true
        println '>>> '
        let input = scan
        let tokens = lex input
        let ast = parse tokens
        let bytecodes = compile ast
        let result = interpret bytecodes
        println result

    redo:
        lines = gen.readLine() # evaluated at least once.
    while gen.hasNext()

    while user = genRandomUser():
        println user.name

    while list.size > 0, for name <- list:
        print(name, newline)
        list .removeTop()

TERNARY OPERATOR
    # ternary operator is a summarized if-else clause.
    var absValue = if a > 0: a \\ else: -a

    var absValue = a > 0 ~ a : -a

    song in playlist ~ play playlist[song]

    # a ternary operator statement needs to be encapsulated in brackets
    # where a semicolon is expected
    if a == (b > c ~ b : c): print a

FUNCTION DEFINITION (2)
    fun multiply(a, b):
        a * b

    # if a function returns nothing, it's return type may be left empty
    #: Str
    fun greet(name):
        println "Hello [name]"

    # to make sure nothing is returned from a function you can use `;` to terminate an exit expression or `_` as the exit expression.
    fun effect(mood):
        if mood.isHappy:
            happySong ->play();
        else:
            sadSong ->play();

    # varargs.
    #: Int -> F64
    fun arithMean(...numbers): # variable number of arguments 
        var total = 0d
        for number = numbers:
            total += number
        total / numbers.size
    ..

    arithMean(1, 2, 3, 4)

    # anonymous functions are nameless functions
    # and they are excuted at the point of declaration.
    fun _():
        return a + b

    # the states local subjects marked with '`' are always preserved 
    # between function calls.
    fun callCount():
        var count` = 0
        println 'count = [count += 1]'

    callCount() # 1
    callCount() # 2

    # functions that change values of arguments must be annotated with `!`.
    #! ref Person, ref Person
    fun swap(!a, !b):
        a, b = b, a;

    swap(john, jane)

    # default parameter values and shared value with `&` binder
    fun login(email = 'demo', username = 'demo', password = 'demo'):
        access Account(username, password)

    login(_, 'nyprothegeek', 'bazinga!')
    login('nyprothegeek@gmail.com', 'nyprothegeek')

    # compulsory named arguments
    fun signUp(username., password.):
        access Account(username, password)

    signUp(username:'appcypher', password:'bazinga')

    fun sendMessage(message, to.recipient):
        println((message + recipient).toUppercase)

    sendMessage('Hello', to:'Cantell')

    fun sum(first., ...rest.): 
        first +. rest

CONSECUTIVE CALL CHAIN
    greet 'John'; greet 'Jane' ; greet 'Lagbaja'
    greet 'John' >> 'Jane' >> 'Lagbaja'
    greet->('John')->('Jane')->('Lagbaja')

    list.getPerson 'Anthony', >> 'Barney', >> 'Rodney'

FIRST-CLASS FUNCTIONS
    # creating new functions from existing functions
    var details = getDetails #: User
    var plus = add(Int, Int -> Int)
    fun times = mul #: F64, F64

    var binaryOp #: Number, Number -> Number
    var binaryOp = Func{Number, Number, Number}

    var range = fun _:
        for i in [..11]:
            yield ++i

    # passing functions to functions
    fun compress image, f: #! Image, (Int, Str -> Int)
        f image

LAMBDAS
    let scoreListWithExtraMarks = scoreList.map(fun _(score): score + 5)
    let scoreListWithExtraMarks = scoreList.map(markFilter)

    fixtureList.filter(|game| -> !game.isCancelled)
    fixtureList.filter(|| -> !$1.isCancelled)

    var pplBelow25 = census.filter(|person| ->
        person.age += 1
        person.age < 25
    )
    
    # you can recall an anonymous function using the recurse keyword
    list.aggregate(0, || -> 
        if $1 == 0: 1
        else: $1 + recall($2, $1 - 1)
    )
    
IMMEDIATELY INVOKED FUNCTION EXPRESSION (IIFE)
    # The value is passed as parameter to the lambda
    var primes = |[2..]|
    | [p, ...xs]: p ++ recall(x << x = xs, x .mod p != 0)

CLOSURE
    # a closure is an inner function.
    fun genDbConnector(host., username., password.):
        return fun makeDbConection: # a closure can be returned.
            db.connect(host, username, password)
    ..
    var dbCallback = genDbConnector(host:'localhost', username:'nypro', password:'willdiearobot')

COFUNCTIONS # NEEDS REVIEW
    fun remove(list, index): #:List[T], Int
        list -= list[index]

    remove += refreshUI # attaching a cofunction.
    emit movieList.remove(2) # emit is used to run the function along with its cofunctions.

CONTEXT LABELLING 
    fun play music: #> top
        if music != nil: music.start()
        |music| ->
            if music.artist "Bieber": 
                return music.artist at top
    ..

    loop: #> outer 
        while file.hasNext(): 
            var line = file.nextLine()
            if line != "":
                println line
            else: 
                break at outer
    ..


EXT SUBJECTS
    let state = 'Idle'

    fun changeState(state):
        if state != nil:
            activateState state
        else:
            activateState ext.state # ext refers to the parent scope.
    ..

USEFUL FUNCTIONS
    typeOf 24
    size([1, 2, 3, 4]) # size is a constant-time operation.
    count("Hello, world!") # count may be a linear-time operation.
    iter(array, 5) # array{5:3}
    seriate array 
    map(names, ||-> $1 + ' ')
    filter(list, |a| -> isPrime a)
    each(list, ||-> println($1, ', '))
    eachIndex(list, |i, e| -> println "[i]: [e]")
    noneMatch(numbers, |a| -> isEven a)
    printf('The circumference of a circle with radius 5 is %f', pi * 5^2)]
    respondsTo(object, add)
    getHighest list
    getLowest list
    getRank(list, 21)

USEFUL CONSTANTS # DEPRECATED!!!
    nl == '\n'
    sp == ' '
    tb == '\t'
    cm == ', '
    bk == '\b'
    pi == 3.141_592_653_589
    e == 2.7182818284590

PATTERN MATCHING
    # match block is like switch-case statement, and it matches against the expression on the previous line.
    object
    | 0          : 1
    | n          : n * n
    | (x, y)     : x + y
    | {a:b}      : a
    | [a:b]      : a, b
    | [x, ...y]  : x
    | Point(x, y): x * y
    | {name, age}: name, age
    | Int        : 'This is an integer'
    | \outer     : outer
    ~ .name == 45: 45
    ~ .> 25      : 'Greater than 25'
    ! .in [1..10]: "not between 1 and 10"
    |            : 'Hello' # otherwise

    # when pattern matching
    return when x 
    | 'a': 1
    | 'b': 2

    print fruit when fruit
    | 'grape'
    | 'apple'

    # you can pattern match with any constract that takes arguments
    while turn != 'y' or 'Y' or 'n' or 'N':
        | 'y' or 'Y': return 1
        | 'n' or 'N': return 0
        |           : print "its an invalid choice."

ASSIGNMENT PATTERN MATCHING
    var [list]        = [2:56]
    var (name)        = [1, 2, 3]
    var {x, y, z}     = Point(4, 5, 6)
    let {keys:values} = dict 
    var a, b, c       = ..."abc" 
    var a, ...b       = list 
    var (i, j, k)     = 50 
    var d, e, f       = 6, 7

COROUTINES
    fun genRandRange(num):
        yield rand(num)
    ..

    var count = for x = [..27]: var z = yield x
    count.next()
    count.send(25)
    count.raise(Error "Just a generic error :/")

ASYNC AND AWAIT
    fun getPerson(name): #@ async
        let p = await getPersonFromServer name.split(/\s+/)
        yield p->name, ->age
    ..

ACTORS # NEEDS REVIEW!!!
    type Task: #@ actor
        var name, time #: Str, Int

    fun Task(name):
        self.name = name
        self.time = random([1:1_000])

    fun sleep(actor): #:: Task
        println "[name] is sleeping for [time]ms"
        sleep time
        println "[name] is done"

    var
        t1 = Task("Task-1") ->sleep
        t2 = Task("Task-2") ->sleep
        t3 = Task("Task-3") ->sleep

TYPE DEFINITION
    type Car:
        var make, model #: Str

    fun move(car): #:: Car
        "Moving"

    # initializer
    fun Car(make, model): #: Str, Str
        new(make, model)
    # new is a special function that creates a new object and maps
    # the arguments to corresponding fields

    fun Car(maker, model, year)
    fun Car ~ # normal # called on Car object during destruction.
    fun Car ! # exception # called on Car object during an exception.

    type Person(!name, !age) # Person is a initializer type.
    # Initializer types have just main initializer and the parameters
    # of the initializer are mapped to fields.

    var john = Person('John Connor', 23)

    type Lamp: var color
    var yellowLamp = Lamp 'Yellow'

    # initializer overloading
    fun Lamp():
        Lamp 'White'

UNION AND INTERSECTION TYPES
    var pegasus #: Bird&Horse
    var identification #: Str|Int

FIELD EXTENSION
    type Programmer(specializedLanguages) <: Person:
        let languages = [Str]

    let orobogenius = Programmer
    orobogenius.languages = ["Java", "PHP", "JavaScript"]

    let appcypher = Programmer(["Dexter", "Java", "C++"])
    appcypher.new.philosophies = ["Open Source", "Transhumanism"]
    appcypher.new.resume = "chicken.poop.com/appcypher"
    appcypher.new.mentor = "Captain Jack Sparrow"

    var nypro = appcypher

TYPE EXTENSION
    type Programmer(specializedLanguages) <: Person:
        let languages = [Str]

    # the `fork` macro allows a type to be extended within a scope.
    type Programmer: #@ fork
        var philosophies, resume, mentor

INHERITANCE
    type Animal
    fun sound(animal): #:: Animal
        println 'Nothing'

    type Bird <: Animal
    fun sound(bird): #:: Bird # overrides supertype function.
        println 'Chirp!'

    type Horse <: Animal:
    fun sound(horse): #:: Horse
        println 'Neigh!'

    # Dexter supports multiple inheritance.
    type Pegasus <: Horse, Bird:
    fun sound(pegasus): #:: Pegasus
        sound pegasus as Horse

    # due to Dexter's multiple dispatch, Inheritance applies equally to all
    # arguments of a function.
    type A
    type B <: A

    fun foo(a, x) #:: A, X
    fun foo(b, x) #:: B, X # this overrides top

    fun bar(x, a) #:: X, A
    fun bar(x, b) #:: X, B # this also overrides top

    # a super method can be called directly or by using super
    fun baz(x, b): #:: X, B
        baz(x, b as base)

INITIALIZER TRAIN
    # initializer train is the way Dexter ensures the initialization of all declared and inherited fields of a particular type.

    # it's basically about making each type responsible for the initialisation of the fields it introduced.

    type Person(name)
    type Teacher(subject) <: Person
    type Student(course) <: Person
    # the initializer train of an initializer type is created automatically

    type TeachingStudent <: Teacher, Student:
        var schedule

    fun Teacher(name, subject)
    fun Teacher(name, course)
    fun TeachingStudent(<name, subject : course>, schedule)
    # (name, subject) is passed to Teacher
    # (course) is passed to Student

    # a sub type should not assign to inherited fields in the initializer.
    # if the compiler finds out an initializer doesn't initialize a field, it complains.

DIAMOND PROBLEM
    fun register(teacher): #: Teacher
        staffList teacher.name

    fun register(student): #: Student
        studentList student.name

    # when TeachingStudent type is declared, an ambiguity error will be issued about `register`.

    # the function needs to be overridden
    fun register(teachingStudent): #: TeachingStudent
        staffList teachingStudent.name
        studentList teachingStudent.name

    var john = TeachingStudent 'John Smith'
    john.register()

    # as a result of these MI issues, Astro advocates favoring single inheritance and composition over multiple inheritance.


ABSTRACT TYPES & FUNCTIONS # @INC
    abst Player # abstract types cannot be instantiated.

    # a function without a body (apart from initializers) is an abstract function and an error is raised if it is called directly.
    # An abstract function is expected to be implemented by a corresponding subtype function.
    fun play(pl) #: Player
    fun rewind(pl) #: Player
    fun fastForward(pl) #: Player

    type DigitalPlayer <: Player
    fun play(dpl): #: DigitalPlayer # this overrides and implements play.
        initPlaylist()
        playPlaylist()

    # Here is an example using abstract types to simulate Algebraic Data Types.
    abst Tree

    #:: $T -> Leaf
    type Leaf(value) <: Tree

    #:: Leaf, Tree -> Node
    type Node(l, r) <: Tree

    #:: Tree -> _
    fun sum t:
        | Leaf: t.value
        | Node: sum(t.l) + sum(t.r)
    ..

    var x = Node(Leaf 1, Node(Leaf 2, Leaf 3))

SINGLETONS
    obj Switch: 
        var on = false

    fun toggle(switch): 
        switch->on ~ ->on = false : ->on = true

    obj adapter <: MouseAdapter
    #: adapter, MouseEvent
    fun mouseClicked(adapter, e): 
        println "Mouse Clicked!"

    window.addMouseListener(adapter)

TYPE CHECKING
    if myCar :: Car:
        println 'myCar is a Car'

    if myCar == Car:
        println 'myCar is a Car or its subtype'

    if myCar <: Car:
        println 'myCar is a supertype of Car'

    if myCar !>: Car:
        println 'myCar is not a supertype of Car'

    head(List[$T] -> T) :: ([T] -> T)

REFERENCE CHECKING
    let a = Person 'John Smith', 25
    let b = a
    let c = val a
    a === b # true
    a === c # false
    (one === other) == (one.ref === other.ref) # true

FUNCTION == METHODS (UFCS)
    fun show(p): #: Person
        println(self.name, self.age)
    ..

    show nigel
    # In Dexter, a function is a method of its first argument.
    nigel.show

    # The only two set of functions that cannot be used with dot operator are
    # contructor functions and new functions.
    type Robot:
        var name, uniqueID
    ..

    fun Robot(name, uniqueID):
        new(name, uniqueID)

    var wall_e = Robot('Wall•E', 215)


ACCESS CHAINING/SHRINKING
    # return chain.
    var result = 8.plus(6).minus(4).times(2)

    # tail object chain
    # a convenience syntax in which the intial associated object forms a long chain of access.
    profile ->open() ->deleteMsgs() ->close()

    # returned object forwarding.
    buffer ->resize(13) ->fill(0, $0)

    # consecutive call chain
    var nameList = [Str]
    nameList.add 'Badmus' >> 'Travis' >> 'Gabriel'

    # chain tupling
    var name, version = haskell ->name, ->version
    var first, second = getPerson 'Seamus', >> 'Flinn'

    # shared dot or arrow
    |a == b|.size ~ a : b
    println john.|name, addrress|.toUppercase

COVARIANCE
    type Person(name, age)
    type Employee(<name, age>, job ) <: Person
    type Teacher(<name, age>, course) <: Person

    #: Person
    fun show(p): # a covariant parameter can take a subtype too.
        println(p.name, p.age)

    show Person('Tony Stark', 36)
    show Employee('Peter Parker', 17, 'Photographer')
    show Teacher('Diana Lane', 12, 'Biology')

    var people = [Person][Teacher(), Employee(), Employee()] # a covariant list.

TYPE CASTING
    var radianInt = Int.(2 * pi) # the resulting value Float of 2*pi is casted to Int.

    fun Employee(person): #:: Person
        Employee(self->name, ->age)

    var deitel = Person('Paul Deitel', 57)
    var editor = Employee dietel

    var yearStr = Str 1990
    let sorted = Int yearStr.sort()

    #:: Float -> MyInteger
    fun MyInteger(num): new(Int num)
    let cost = (MyInteger price) * qty

NAME ALIASES
    type Number = Integer|Float|Complex
    fun cheb = chebyshevCoefficient
    let pi = thisIsAPiConstant

FUNCTION & TYPE OBJECTS
    fun foo = bar(5, 6)
    type BookTitle = Str

    var
        qux = 5
        doo = bar(Str -> Int)

    fun mix(a):
        | 1: fun add(a, b): a + b
        | 2: 25

    fun baz = mix 1 # error
    var bin = mix 1

MODULES AND IMPORTS # NEEDS REVIEW!!
    # when you import a module, every public member is imported into the namespace.
    import
        .appy.BananaTree
        com.nypro.[AppleTree, GuavaTreeTree] # import two
        com.nypro. # import all

    # import some
    import
        com.appy.BananaTree(Trunk, grow)
        com.nypro.[
            AppleTree(Leaf, AppleFruit as Apple), 
            GuavaTree(grow, Seed)
        ]

    # don't import
    import: com.appy.BananaTree(germinate no grow)

    # global subjects can only be passed by value from one module to another.

GENERICS
    # declaring a generic type T.
    #: $T, T, T -> T, where T<:Int 
    fun add(a, b, c):
        var d = T
        d = a + b + c

    var sum = add[Int](2, 4, 6)
    # if the generic parameter can be readily inferred, then type argument can be ommited.
    var sum = add(2, 4, 6)

    # yielded type
    #: [($T, T)] -> T
    fun bmi(xs):
        fun bmi(weight, height): weight / height ^ 2
        bmi(w, h) << (w, h) = xs


    # in case you want a type of function to have its generic arguments in certain order
    # you can put it in a type annotation surrounded by brackets
    type MyList: #: $(T, :len), where len::Int
        let list = Dict[T, T](len, len)
        let size = len

    var list = MyList[Int, 5]()

    # exhaustive generics
    #: MyList[$T], $U -> T, where U::MyList.U
    fun getItem(list, index):
        list[index]

    let identifier #: $T<:Identfiable

    var pegasus #: $U<:Horse&Bird

    var x = 10
    let y = typeOf x # this makes y have the same type as x

TYPE OBJECTS # @INC
    # unconventionally, Dexter has Type objects which can be held by subjects.
    # Sometimes, this concept may clash with generics, but they are basically different
    # constructs with overlapping features.

    var number = typeOf Bool # covariant subject
    # number can hold Bool.type or its subtypes.

    Int <: Integer # true

    fun haveSameTypes(x, y):
        x and y == typeOf x
    ..


ENUMS
    # in a way, enums are types that contain declaration of subtypes.
    enum Days:
        sunday, monday, tuesday, wednesday, thursday, friday

    # one thing to note is that an enum elements are directly accessible
    # within the file.

    var today = friday

    fun todo(day): #: Days
        | sunday: sleep
        | monday: work
        | friday: tgif
    ..

    enum Integral:
        unsignedIntegral(value) #: Unsigned
        signedIntegral(value) #: Signed
    ..

    # enums can have field too, which enum elements inherit
    enum Cars:
        let make, model
        mustang
        ford
    ..

    # enums can inherit from other enums and types.
    # it's more of inclusion than inheritance
    enum NewTools <: OldTools:
        unity,
        django,
        sass
    ..

    # Algebraic Data Types
    enum Tree:
        leaf(value) #: Int
        node(left, right) #: Tree, Tree
    ..

    fun sum(t): #: Tree
        | leaf(v): v
        | node(l, r): sum(l) + sum(r)
    ..


OPERATOR OVERLOADING # NEEDS REVIEW!!!
    # special characters
    # these are characters that cannot be combined with conventional identifier
    # characters to form new identifiers. The only exclusions to this are
    and, or, not, in # they can be used in conventional identifiers
    # special operators are to be infixed without the dot notation.

    # indefinite characters
    # these characters can only be used with other special characters of
    # the same set to create new special identifier.
    = + - * / ^ √ & | > < =(special_chars)

    # definite characters
    # these group of characters cannot be overloaded as is, but can be combined
    # to form new identifiers.
    (special_chars)= :: <: >: >> << . ~ => !

    # language-level characters
    # this group of characters cannot be overloaded nor can they be combined
    # with other special characters to form new characters.
    -> , . $ \\

    # reserved operstors
    \ = prefix
    | = prefix and postfix
    / = prefix and postfix

    # you can call an operator like a function
    println(+(56, 5))

    fun in(x, y): #@ infix(5, 20)
        for a <- y: 
            a == x ~ return true
        false 

    fun ++(x): #@ postfix(5, 10)
        var t = val x 
        x += 1
        t
    
    fun getIndex(myList, index): #: MyList
        return myList.items[index]

TRY, CATCH & ENSURE
    if numerator and denominator == 0:
        raise DomainError.() # raising an exception.
    
    try: 
        process bigData  
    catch err:  
        println err.msg
    ensure:
        restore bigData

    try process(bigData):
    catch err: #: DivByZeroError
        println err.msg

    try data = getData(): 
        use data 

    # ensure block can be put at the end of a function, it 
    # executes before the function closes
    ensure: 
        file.close

    while try line = file.readNextLine: 
        println line
    catch FileNotFounError:
        println 'File missing!'


MACROS # NEEDS REVIEW!!!
    # Dexter macros are resolved at parse time.
    # rather than using the AST, Dexter macros work on parse tree.

OTHER LITERALS # @INC
    let fraction = 3//2 # rational numbers.

    var complex = 1 - 1im # complex numbers.

    var regex = /\d+(.\d+)?/ # regex.

    var block_regex = //^ (
      ?: [-=]>
       | [-+*/%<>&|^!?=]=
       | >>>=?
       | \.{2,3}
    )
    //

    # non-standard literals
    var ns_number = 345_NGN
    var ns_str = ns.'1, 2, 3, 4'
    var ns_list = ns.[1, 2, 3, 5]
    var ns_dict = ns.{name: 'Steve', age: 24}
    let ns_tuple = ns.(name: 'Steve')

    # builtin non-standard literals
    var raw_string = r."\t represnts a tab character"

BUFFER TYPE
    # buffer is a base array that types like List, Str, Chars use to build their internal
    # array structure.
    let int5 = Buffer[Int](5)
    # You can resize and also fill a buffer.
    let buffer = Buffer[Int](10, 10).fill(0)
    buffer ->resize(1, 20) ->fill(0, $0)

BASIC ARITHMETIC OPERATIONS
    let t = 2 + 2
    let u = 5f * 20d
    var v = 5 / 2 # this returns an F64 even though the operands are Ints
    var w = 5 ~/ 2 # this returns a clamped Int result of the above
    var x = 6 % 5
    let y = 5i16 ^ 2_i8
    let z = I8(√25)

INTEGER BITWISE FUNCTIONS
    var x = 2 .bitand 5 # and
    var y = 3 .bitor 6 # or
    var z = 6 .bitnot # not
    var a = 7 .bitxor # exclusive or
    var b = a .bitshl b # bit shift left
    var c = b .bitshr a # bit shift right

UNICODE SUPPORT 
numbers.map(|x| -> x²)

if ade.mood != happy: 
    ade.mood == ☹

PREDEFINED TYPE HIERARCHY
    Any
        Type
        Func
        Indie
            Real
                Integer
                    Signed
                        Int, I8, I16, I32, I64,
                    Unsigned
                        UInt, U8, U16, U32, U64
                Float
                    F32, F64
            Complex
                Cmp64, Cmp128
            Bool
        Array
            Buffer
            List
                AbStr
                    Str, Chars
                Range
                Indexer
            Tuple
                Name Tuple
        Generator

POSSIBLE COMPILER DEPENDENCIES
- libffi    (foreign function interface)
- gmp       (bignum)
- libprce   (regex)
# - libmill   (goroutines)

ASTRO STRUCTURED LANGUAGE PROPOSAL 
dsl src='hello', link='bar.io':
    (print 'hello') # astro code
    list: [1, 2, 3] # 

# END
