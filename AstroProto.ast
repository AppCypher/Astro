# 23/07/17
# Astro 0.1.0
x if y == x else (y if y == z else z)
# TYPE CONVERSION FUNCTIONS 
- camelCase names of types are now by convention meant for type conversion operations
type Int
fun int(float): #: F32
    int float

# 20/07/17
# Astro 0.1.0
# LIST COMPREHENSION
var l = [x | x <- [:200], even x]
var s = {x | x <- rand([:20]), even x}
var d = {x : y | x <- [:50], y <- [:x], even x}

<< block_expr
:  block_expr
<- block_expr
-> block_expr
(  block_expr)
{  block_expr}
[  block_expr]

# 19/07/17
# Astro 0.1.0
# LIST COMPREHENSION 
let l = [x * y | x <- [:10], y <- [:x], x % 2 == 0]
let s = [x <- numStream()]

# IF | FOR | WHILE
if x <- value?: 
    print x  
 
for x <- [:20]: 
    print x  

while x < num: 
    print x  

# IMPORT | EXPORT  
import state, tables
import math [sin, cos]
export math except [pi]

# MAIN FUNCTION  
fun main():
    println "Hello world!"

# INDEXING  
var x = y[:end] 
var y = z[end:]

# BITWISE OPERATORS
var state = flag1 .band flag2
var state = flag1 .bor flag2

# INSTANCE TYPES
add(3, 4) :: Fun:(Int, Int) -> Int 
car :: Car:{Str, Str, Int}

# PROPERTIES
var age = (age + 1) >> (age - 1)




-----------------------------------------------
# 18/07/17
# Astro 0.1.0
# MAIN FUNCTION  
fun main():
    println('hello')
    scanln('> ')
    readln(fileObject)

# INDEXING 
var x = y[:end]
var x = y[end:]

# LIST COMPREHENSION 

# FOR (DEPRECATING WHILE)
for x << numStream():
    print x

foo( x, y = y, x )
foo( yield x * y for x, y <- [:10], numStream() if x % 2 == 0 )

var x, y = y, x

if x << getNumber():
    print x

for x, y << numStream(), boolStream(): 
    print x 

for x != genNum(): 

redo: 
    print x 
for x == age

while x << numStream(): # unsupported
    print x 

# COMPREHENSION NEEDS WORK

<< block_expr
:  block_expr
<- block_expr
-> block_expr
(  block_expr)
{  block_expr}
[  block_expr]

x << [:34]
x <- (x, y) << ([:34], [1:45]) if x == 25

(x, y, z) <- 
    z, x, y << 
        [1:21], [1:z+1], [1:y+1] 
    if x² * y² == z²

for_expr =
    | parens_expr for_head if_head? end_expr?

if_expr = 
    | parens_expr if_head else_expr?  

while_expr = 
    | parens_expr while_head if_head? end_expr? 

expr = 
    | block_expr  
    | parens_expr 

parens_expr =
    | fix_expr 
    | list_comp 
    | atom

atom = 
    | parens_atom 
    | ...

parens_atom = 
    | '(' IND (block_expr ) DED_START_DEFERRABLE ')'
    | '(' IND (long_expr | atom) DED_START_DEFERRABLE ')' // IGNORE_NL 
    | '(' (long_expr | atom) ')' // IGNORE_NL

long_expr = 
    | expr (';' expr)+ 

block_expr = 
    | block_decl  
    | block_cond 

fun_call = 
    | name '(' IND named_arg (',' named_arg)* DED_START_DEFERRABLE ')'  // IGNORE_NL
    | name '(' named_arg (',' named_arg)* ')' // IGNORE_NL
    | ...

DED =
    | DED_START 
    | DED_INLN 

DED_START = 
    | DEDENT

DED_INLN = 
    | '\\' NS  '\\'


match = 
    | 

list_comp = 
    | (parens_expr '<' NS '-')? for_head_content (CNL? for_head_content)* (CNL? if_head)?
    | for_head_content (CNL? if_head)?

list_comp_block = 
    |  

iife = 
    | 

lambda = 
    | ('|' params '|')? '-' NS '>' expr_or_block
    | '|' assign_pattern (',' assign_pattern)* '|' '-' NS '>' expr_or_block

import = 
    | 'import' ('[' name (':' name)? (',' name (':' name)? )* ']')? ('except' '[' name (',' name )* ']')? 

export = 
    | 'export' ('[' name (',' name )*']')? ('except' '[' name (',' name )* ']')?


# 14/07/17
# Astro 0.1.0
# CONDITIONS 
x == y || z
x == y or x == z

error  
| TypeError || DomainError -> log(.issue)

# BITWISE 
var state = flag1 &&& flag2

# 12/07/17
# Astro 0.1.0
# COMPREHENSION NEEDS WORK
sum( yield rand() < 0.5 for i << [:t] if i % 2 == 0 )
sum( rand() < 0.5 : i << [:t], i % 2 == 0 )

list(i << [:t])
dict((a,  b) << table if a == 5)
list(a * b <- (a, b) << table)

(x, y, z) <- 
    z << [1:21]
    y << [1:z+1]
    x << [1:y+1] 
    if x² * y² == z²

# INSTANCE TYPES
add(3, 4) :: Fun:(Int, Int) -> Int 
car :: Car:{Str, Str, Int}

# IMPORT  
import math 
import math except [tan, atan]
import math [pi:π, cos, sin:sine]

# EXPORT  
export math except [cos, sin]

# 11/07/17
# Astro 0.1.0
# IIFE
(2:a, 5:b) -> a + b

() ->
    if toks.parseString("{").success:
        if toks.|parseString(":") & parseString("}")|.!success:
            return { success: true, ast: null, lastPointerPos: null, name: null, problem: null }
        doSome stuffs

# GET//SET  
var prop = (prop) ~> (prop)

# Returning Nothing 
fun print(point): #: -> None 
    print point.|a, b|

# 06/07/17
# Astro 0.1.0
if parseResult = parsePASS(), if parseResult.success: 
    print "Parser successful  == [parseResult.success]" 

if (var parseResult = parsePASS(); =>success): 
    print "Parser successful == [parseResult.success]" # error, parseResult not accessible


# Astro 0.1.0
# IIFE // DEPRECATED
var x = (|a, b| -> a + b)(2, 3)

var x = |2, 3| -> $1 + $2 # literals and outers
var x = |2, getValue(x)| -> $1 + $2 # literals and outers

# 03/07/17
# Astro 0.1.0
# IIFE
var x = (|a, b| -> a + b)(2, 3)

var x = |2, 3| -> $1 + $2 # literals and outers

# UNIICODE MATH SYNTAX PROPOSAL
var calc = { 2x / 56y }f

# 01/07/17
# Astro 0.1.0
# RETURN NOTHING 
fun print(object): #: -> Nada
    print object.|id, position|

# NS LITERAL 
let spMatrix = 2x2 [Int] sp_[]

# NESTED DESTRUCTURING  (REJECTED)
let {a: {b}, c} = dict  
var [a, [b], c] = list 
var {a, {b}, c} = set  

# REMOVED RHS var and let
let x = const [1, 2, 3, 4]

# BITWISE OPERATORS
band
bor
bnot
bxor
bshl
bshr

# 29/06/17
# Astro 0.1.0
# LIST FIELD GENERATOR SYNTAX
let students = getStudentList()
let totalGpas = students.@gpa.sum()

fun average(students):
    students.|@gpa.sum() / size|

# CHANGE DICTIONARY VALUE ACCESS SYNTAX
fun set(a, b): pass #: $T

type Foo: 
    var set = {Int: add(_, 5)}

var object = Foo()

object.set[Int](x)
object.set{Int}(x)
# IMPORTING  
import 
    math.{pi, cos, tan}
    math.{_} # import all
    game.{physics, events no lighting} # don't import
    plant.{Apple as ap, Mango as mg}  # import as
    src.com.appy.android.{MainActivity} # follow path from src


# 28/06/17
# Astro 0.1.0
# IMPORTING  
import 
    math.[pi, cos, tan]
    math.[_]
    game.[physics, events no lighting]
    plant.[Apple as ap, Mango as mg]
    src.com.appy.android.[MainActivity]

# TUPLES BACK! 
# tuple is a datatype whose element types and length are determined statically
# you can't do much with tuples except to pass them around. You can't appended to or removed from
let tuple = (1, 2, "Hi")

# DESTRUCTURING REDESIGNED
let [name, age, _, ...rest]  = list
let (name, age, _, ...rest)  = tuple
let {name, age, _, ...rest}  = dict
let {name, age, _, ...rest}  = set
let [first|last] = list
let (first|last) = tuple
let {first|last} = dict 
let {first|last} = set 
let {key:value}  = dict 

# FUNCTIONS CAN ONLY TAKE TUPLES 
fun check(f, ...args):
    let test = f(...args[:-2]) == args[-1]
    println 'Test passed' if test else >> 'Test failed'

check(add, 5, 3, 8)
check(sub, ...list) # error!

# APPLICATION PIPING 
add(2, 3) |> sub(_, 5) |> div(2, _)

fun |>(f, x): #@ infixl(5)
    f(a)

# 27/06/17
# Astro 0.1.0
# PARTIAL FUNCTIONS
list.map mul(_, 5)

# DEFAULT VALUES
fun createAccount(name:"demo", password:"demo"):
    accountFactory(name, password)

createAccount(password:"Logic404")

# VECTORIZATION 
vector .cross.. matrix

# CHAR AND ASCII TYPE, NO MORE CHARS 
let pi  = ch_"π"
let euler = as_"e"

fun getPerson(): # -> Dict[Str, _]
    return { name:"James", age:56, gender:"Male" }

# '!' OPERATOR POSITIONING
x.!isRound 
x !in y 
!x?
!(x.hasValue(y))

# NO MORE TUPLES 
var a, b = 5, 6

fun john(name, age):
    name, age 

# RANGE NOT INCLUSIVE 
var range = [:10] # 0 to 9


# 26/06/17
# Astro 0.1.0
let x, y = z, a = 5, b # Removed!

# 25/06/17
# Astro 0.1.0
# FUNCTION OF A FUNCTION 
fun vecr(f, scalar, list):
    list.map->(f(scalar, $1))

dot.vecr(matA, matB) # deprecatable
vecr(dot, matA, matB) 
matA.dot.vecr(matB)

[].join.toEach(list)

# GETTER SETTER SYNTAX PROPOSAL
var age  = (age + 5) -> (age - 5)
var name = (name) -> (name + "Smith")
var date = (date) -> ()

# adjustments to make
- identifier section. [DONE]
    fun createMeme(): 
        println memes[rand()]      
        
- in values and reference section, remove [DONE]
    let library = acq
  a subject assignment type cannot be pre-declares
  
- in for loop section, remove [DONE]
    for var i <- ...
    
- correct all occurrences of 'for .. = ..' [DONE]

- edit value constraint [DONE]

- edit generic parameter order syntax [DONE]

- add to grammar [DONE]
    :=
    +=
    
- add rxn as keyword [DONE]

- the nil operators can be placed infront of a function identifier with a brackeless call [DONE]
    let x = getX(name, age)?
    let y = getY? name 

- single-line comment ends at newline or ; [DONE]

- instantiating coroutine.  [DONE]
    var x = coroutine(2, 5)

- edit error coalescing [DONE]
    var x = getValue() !! 78
    
- exhaustive pattern match with if [DONE]
    value
    | TypeB(s1, s2) if |s1 == s2|.length -> println(s1 + s2) 
 
- change lazy assignment to lazy subject declaration. [DONE]

- change setter/getter syntax. [DONE]
    from:
    var age = set: age + 5 \\ get: age - 5
    var name = set: name \\ get: name + "Smith"
    var date = set: date
    to:
    var age  = (age + 5) -> (age - 5)
    var name = (name) -> (name + "Smith")
    var date = (date) -> ()

- add ', NL? |NL ,?' to section 'where used'. list, dict, enums, chainedconditionalconstruct [DONE]

- remove vectorization syntactic sugar from the language, and added 
- new function of function syntax that makes vectorization possible [DONE] 
    fun vecr(f, scalar, list):
        list.map->(f(scalar, $1))

    dot.vecr(matA, matB)
    vecr(dot, matA, matB) 
    matA.dot.vecr(matB)

- a function can call itself with 'fn' keyword [DONE]

- check commits for updates made to the language [DONE]

- add to 'what if astro had braces' section [DONE]
    var students = getStudentList()
    students.{gpa}.map->($1 + 1)

# 22/06/17
# Astro 0.1.0
# CACHED EXPRESSION PROPOSAL (REJECTED) # compiler can optimize it away
# expressions in a loop that don't change during iteration
# can be cached for reuse
students.count->$1 >= `average(students)

# LIST FIELD 
students.|{gpa}.sum() / size|

# MUTABLE / IMMUTABLE OBJECTS 
var name = let Name('Steve', 'Akin')
let list = var [1, 2, 3, 4]

# LAZY ASSIGNMENT  
var lazyNum := 45
...
lazyNum := 67 

# COMPREHENSION PATTERN MATCHING
    [i] << i <- [1:20]
  {i:5} << i <- [1:20]
   (i,) << i <- [1:20]
 Set(i) << i <- [1:20]

# ERROR COALESCING  
let x = getSomething() !! ->(| Error -> .printTrace())

# DO NOTHING  
fun add(a, b): pass 
if a == y: pass 

# DO IF MATCH  
print(.name) if person.name 
| 'Steve'
| 'John'

# REUSE PATTERN 
let x = 0 
if $x = getValue(): 
    println x

# 15/06/17
# Astro 0.1.0
# GENERICS. POSSIBLY THE SAME TYPE
#: !T, !U -> T|U
fun max(a, b): a if a > b else b

# 13/06/17
# Astro 0.1.0
# DEFER 
var file = open('file.txt')
defer: file.close

# 13/06/17
# Astro 0.1.0
# PROPOSED REST SYNTAX (REJECTED)
[head, _tail] = list

# 10/06/17
# Astro 0.1.0
# NIL MARKERS # DONE
getData!('abc')
getData?('abc')

# ANONYMOUS FUNCTIONS # DONE
var add = fun (a, b): a + b 
# NON-STANDARD LITERAL # DONE
let x = set_[1, 2, 3]

let car = struct_{
    name: 'Shelby Camaro',
    make: 'Chevrolet'
}
# ARROW NOTATION # DOC
playlist =>play() =>shuffle() 
# EXPORT # DOC
export 
    add #: Int, Int -> Int
    Person #: Str, Str, Int
# ACCESS MODIFIERS # DONE
type Employee`(!job`, !age`) <: Person
fun add`(a, b): a + b
# MUTATION # DONE
fun sort(!list)
fun swap(!a, !b): 
    a, b = b, a;
# BRACKETLESS CALL # DONE
- BRINSL (boolean, regex, indentifier, number, string, lambda)
# PROTOTYPE # DONE
var dude = { name: 'Sonny', age: 16 }
dude.new.gender = 'male'
dude.new.job = anotherDude.job  
dude.inc.move = |source, destination| =
    println 'Moved from $source to $destination'
# USING SUBJECTS FROM OUTSIDE # DONE
var person = { $attrib1: 'John', $attrib2: 25 }
var playing = "playing $song..."
object
| $something -> println "$attrib1 is [getname(object)]"
# IIFE # DONE
|10| = 1 if $1 == 0 else fn($1 - 1) 
# TERNARY CONDITION EXPRESSION # DONE
stop music if music.playing else play music
# SINGLETONS # DONE
button.setOnClick(obj <: OnClick: 
    fun onClick(self, view): 
        println "Button clicked!"
)
# DESTRUCTURING LAMBDA # DONE
list.map |(x, y)| = x * y
# LAMBDA REDESIGN # DONE
list.fold(0, |x, y| = x + y)
list.fold(0) |x, y| = x + y 
list.fold(0, =$1 + $2)

fun vowels(word) = word.filter(=$1 in "aeiouAEIOU").size

var castle = |a, b| =
    exec(a, b)

var castle = (=exec())

# 02/06/17
# Astro 0.1.0
# LAMBDA REVISITED
20.each || -> println "Hello"

list.map |x| -> x * x

fun check(x) = |x.id| ->
    | 'Don': 2
    | 'Dan': 1

fun four = 2 * 2

# WHEN REVISITED
return _ when x
| 1: '1'
| 2: '2'
| 3: '3'

print(_) when x
| 1: x
| 2: x
| 3: x

# 01/06/17
# Astro 0.1.0
# MATCH BLOCK REVISITED
while turn != 'y' or 'Y' or 'n' or 'N':
    | 'y' or 'Y': return 1
    | 'n' or 'N': return 0
    | _         : print "its an invalid choice."

fun palingram(word):  #: Str
    | .size() == set(word).size(): "isogram"
    | word[-1:]                  : "palindrome"
    | _                          : "nothing"

fun compare(a, b): 
    ~ a == b: 'eq' 
    ~ a != b: 'ne'
    ~ a > b : 'gt'
    ~ a < b : 'lt'
    ! a > b : 'le'
    ! a < b : 'ge'
    