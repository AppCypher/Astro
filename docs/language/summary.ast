# Astro 0.1.12
SINGLE-LINE COMMENTS
    # Hello, World!

MULTILINE COMMENTS
    #=
        Multiline comments can span multiple lines.
        They begin with `#=`.
        #=
            They can be neste.
        =#
        And they end with `=#`.
    =#

SUBJECT BINDING
    # In Astro, subjects are names to which values or objects are bound.
    let team = 11 # The value, `11`, is bound to the subject, `team`.

    # Initialization can be deferred to later.
    let hello
    hello = 'こんにちは'

    # A subject cannot be used without binding it to a value first.
    let string
    print(string) # Invalid!

    # The `let` keyword is used for subjects whose values cannot change.
    let immutable = 10
    immutable = 50 # Invalid!

    # The `var` keyword is used for subjects whose values can change.
    let mutable = 10
    mutable = 50 # Subject value changed to 50.

    # The expression that comes after an assignment operator can be moved to the next line with a preceding indentation.
    var φ =
        arctan(y/x)

    # Declaring and binding multiple subjects to the same value by separating them with spaces.
    let a b c = 50

SHADOWING
    # Astro allows subjects to be rebound to a different type in the same scope
    let phone = '08074789222'
    let phone = 08074789222 # `phone` rebound to an object of different type

IDENTIFIERS
    # Name of subjects must always start with a character and can be followed with characters, digits or underscore.
    var my_name
    fun doNothing(): pass

    # Names preceded by underscores are special to the compiler.
    # Likewise, uppercase single letter identifier are reserved for generic type annotations.
    let _song = 'Sorry' # Invalid!
    let T = 5 # Invalid!

    # Naming convention.
    # Camel case for variables, constants, function names and module names.
    let bookTitle = "Ender's Game"
    fun addNumbers(a, b): a + b

    # Pascal case for concrete and abstract type names.
    type InventoryManager(name, id)
    abst LightSource: SpotLight | Directional | Ambient

    # For acronyms, only the first charcater should be upper case.
    type XmlParser <: Parser

VARIABLE/CONSTANT OBJECTS
    # Objects are variable by default but can be made immutable with the const keyword.
    var name = const Name('Steve')
    let list = const [1, 2, 3, 4]

FUNCTION DEFINITION (1)
    fun add(a, b): # Parameters are immutable by default.
        return a + b

    fun swap(var a, var b): # `var` keyword makes a parameter mutable.
        a, b = b, a

    # The block begin punctuator, `:`, can be replaced with `=` for single expression definitions.
    fun add(a, b) = return a + b

    # You can annotate the argument and return types of a function.
    fun modulo(a, b): #: (Int, Int) -> Int
        return a % b

    # Astro is indentation-based, but for legibility reason blocks can optionally be delimited with `..`.
    fun sub(a, b):
        a - b
    ..

COMMAND NOTATION
    # If a function call takes just one argument, the parens can be ommitted given the argument is not a list, dict, set or regex literal or preceded by a prefix operator.
    # This is necessary due to ambiguities that may otherwise be caused when parsing or reading the code.
    print "Hello"
    print name
    print 56

    print [9] # Invalid!
    print {9} # Invalid!
    print /9/ # Invalid!
    print +5 # Invalid!

TYPE DEFINITION (1)
    # A type is synonymous with struct in C. It holds the blueprint of what an object can contain.
    type Person(name, age)

    # Objects can then be created from the blueprint.
    var jane = Person('Jane Doe', 50)

PROPERTIES
    # Properties provide a setter/getter behavior.
    # The first brace pair represents the setter, and the second braces pair, the getter.
    var age  = {age + 5} -> {age - 5}

    # The last expression in the setter braces becomes the property's value.
    # The last expression in the getter braces is the property's returned value.
    var name = {name} -> {name + "Smith"}

    # Empty braces means the setter/getter is inaccessible.
    var date = {date} -> {}

EXPRESSION-ORIENTED
    # Everything (except the import and export statements) is an expression in Astro!
    var isNyproCrazy = (faveHobby == 'CountingBirds')

    # Type definitions, function definitions, loops, etc. all return some value.
    # In the case of a for loop, the last expression on the final iteration is returned, if there is no break.
    let cube = for i in 1..10: i³

    # The last expression of a function is always returned.
    fun add(a, b):
        a + b # The result of a + b will be returned to the caller.

    hieght = add(2, 3)

    # A semi-colon at the end of a block, stops it from returning its last value
    fun setName(p, name): #: (Person, Str)
        p.name = name;
    ..
    let name = setName('John Smith') # Invalid! setName returns no result.

SPECIFYING TYPES
    # Types can be automatically inferred in Astro.
    var todo = 'Create a new programming language :)'

    # However you can still specify types explicitly using '#:' type comment.
    var number #: Int

    # Union types.
    var identifier #: Str | Int

    # Intersection types.
    var pegasus #: Horse & Bird

SOME BUILT-IN TYPES
    var index = UInt(2_000) # Unsigned integer type.

    let e = 2.718281828459045 # 64-bit floating-point type.

    let dogBreed = Str('German Shepherd') # Immutable UTF-8 string type.

    var listOfGroceries = ['Oranges', 'Cabbages', 'Tomatos', 'Bananas'] # List type.

    var game = 'BioShock Infinite', 2014 # Tuple type.

VALUES & REFERENCES
    # By default primitive objects (UInt, Int, Float32, Bool) are passed around by value.
    # and by default complex objects (Str, user-defined types) are passed around by reference.
    # however, you can change this behavior with 'ref' and 'val'.
    let string = "Gift"
    let number = 1000

    # Passing a complex object by value.
    var newString = val string

    # Passing a primitive object by reference.
    var newNumber = ref number

    # Astro manages memory automatically using a special reference counting technique, it handles reference cycles as well.
    myCompany.affiliate = ref yourCompany
    yourCompany.affiliate = ref myCompany

    # `iso` is used to hold an exclusive reference to the object.
    let developer = iso 'AppCypher'
    let anotherDeveloper = developer # Invalid!

    # While `val` is a shallow copy operation, `acq` is a deep copy operation.
    let rent = val house
    let buyer = acq game

    let player = team.player

    # An immutable reference to an object can be returned from afunction using the `const` keyword.
    fun getAmount():
        return const amount

    # Reference type annotation.
    fun swap(var a, var b): #: (ref T, ref T) -> None
        a, b = b, a
    ..

NUMBER LITERALS
    # Number literals in Astro
    var index = 5 # Int literal.
    var axis = -3 # UInt literal.
    let meters = 0.25e-5 # Float64 literal.
    let salary = 10_000'f #' `'f` marks the number literal as Float64.'
    var price = 0x6FFF00p+12 # Hex literal.
    var opCode = 0b10110001 # Binary literal.
    var interest = 0o566768 # Octal literal.
    let pi = 3.14'bf #' BigFloat literal.

TUPLES
    # Tuple is an immutable datatype whose element types and length are determined statically.
    # Tuples cannot be appended to or removed from.
    var name, age = 'Emeka Okorafor', 27 # Open tuple.
    var game, year = ('Uncharted 4', 2016) # Closed tuple.

    # Tuple destructuring.
    let person = 'Sam', 50
    let name, age = person # name = 'Sam', age = 50
    let (name, age) = person # name = 'Sam', age = 50

    # Tuple unpacking.
    let arguments = (5, 6)
    add(...arguments)

    # Empty tuple.
    let map = ()

    # One-element tuple. Note the trailing comma.
    let map = (london,)

    # Named tuple are tuples with keys.
    let http = (statusCode: 200, description: 'Ok')

    # The contents of a named tuple can be accessed using the dot notation.
    print http.status

LISTS
    var unorderedList = [7, 3, 8, 5, 4, 0, 9, 1, 2, 6]

    var emptyList = []

    # Specifying a list type.
    var names #: [Str]

    # Heterogenous list.
    var stuffs = [500, 'Steve', 1.0]

    # Astro uses 0-based indexing. Every list indices start at 0.
    stuffs[0] # 500

    # Slicing a list.
    contestants[1:6] # 2nd to the 5th index.
    contestants[1:] # 2nd to the last index.
    contestants[:6] # first to the 5th index.
    contestants[:] # first to the last index.

    # A slice can have a step value.
    let odds = numbers[1:2:30] # The step value is the `2` in the middle.

    # `!` is used to access the index backwards.
    var last = contestants[!0] # last index.

    # Using negative step to reverse index access.
    var reversed = contestants[:-1:]

    # Reverse access can also be done using `!`.
    var reversed = contestants[!0:]

    # Using a constructor to create a List.
    let number = List[Str](4, 4, "")

    # Field mapping.
    students.map(|x| => x.gpa)
    students.$gpa # Same as above

    fun average(students) = sum(students.$gpa) / students.size

    # List operations.
    var concatenate = [1, 2] ++ [3, 4] # [1, 2, 3, 4]
    var multiply = [1, 2] ** 2 # [1, 2, 1, 2]

ARRAYS
    # Array is a supertype of List and works a bit differently from List.
    # Arrays can be used pre-allocate uninitialized uni/multi-dimensional buffers.
    # If the type of elements is not specified, the element type will default to F64
    let matrix = 5×5[]
    let matrix = 5*5[] # Alternate syntax

    # Because Arrays can be more efficient, they can be used to represent matrices.
    let a = 2×4[
        [1, 2, 7, 8]
        [3, 4, 5, 6]
    ]

    # A 2-dimensional Array can be created using horizontal concatenation with `;`.
    let a = 2×4[
        1, 2, 7, 8;
        3, 4, 5, 6
    ]

    # Using a constructor to create an Array.
    var matrix = Array[Int](2, 2)

    # Setting the indices of a multi-dimensional Array.
    matrix[,] = [
        1, 6;
        3, 7
    ]

    # Multi-dimensional array slicing
    let subset = mat4[1:, 1:2]

    # Vectorization syntax.
    let z = 5 + subset.
    let y = add(subset., 1)

    # Astro's lists are, by default, row-major order.
    let y = [1, 2, 3]
    # [1 2 3]

    # An Array's order can be changed using the transpose operator, `'`.
    let z = [1, 2, 3]' # Transposition'
    # [1]
    # [2]
    # [3]

    let a = [1, 2; 0, 4]

    # Array unpacking.
    let b = [
        ...a', ...a;
        ...a, ...a'
    ]
    # [1 0 1 2]
    # [2 4 0 4]
    # [1 2 1 0]
    # [0 4 2 4]

    # Indexed integral numbers clash with array literals, so defining `getIndex` on integral types is not allowed.
    # Also when multiplying by an array literal, the literal needs to be enclosed in parens.
    let result = 3×(4[])

OBJECTS & DICTIONARIES
    # Objects and dictionaries are both associative data structures.

    # Objects are static construct and can be introspected at compile-time.
    let game = { title: 'BioShock Infinite', year: 2014 } # Property

    # Dictonaries are dynamic data structures and will return nil where expected key is not present
    # Dictionaries literals are marked with `dict`.
    let game = dict.{ title: 'BioShock Infinite', year: 2014 } # Dictionary.

    let parents = {
        'mum': {
            'name': 'Esther Williams'
            'age': 42
        }
    }

    # Unquoted keys are taken as strings as well.
    let parents = {
        dad: {
            name: 'Sunday Williams'
            age: 46
        }
    }

    # Nested object can be simplified with indentation.
    let siblings = {
        sister:
            name: 'Shade Williams'
            age: 15
    }

    # Object fields are accessed using the dot operator.
    let sister = siblings.sister.name

    # Dictionary values are accessed using `{}` and can return nil.
    let mum = parent{'mum', 'name'}

    # Dictionary values can also use accessed using the dot operator, but since dictionaries can return nil, the nil operator is needed.
    let mum = parent.mum?.name

    # New fields can be added to an object.
    siblings.brother = {
        name: "Daniel Williams"
        age: 23
    }

    # To use variables from the outer scope, the variable name needs to be escaped with `$`.
    var professor = {
        $id1: 'Charles Xavier'
        $id2: 56
    }

    # Empty object.
    var emptyDict = {}

SET
    # Set is an unordered collection of items with no duplicate elements.
    let fruits = set.['orange', 'mango', 'guava', 'apple', 'orange', 'guava', 'pineapple']
    let citrus = set.['lime', 'lemon', 'orange']
    fruits.size # 4

    # Set operations.
    let union = citrus | fruits # set.['lime', 'lemon', 'orange', 'mango', 'guava', 'apple', 'pineapple']
    let intersection = citrus & fruits # set.['orange']
    let difference = citrus - fruits # set.['lime', 'lemon']

RANGE
    # Range is an iterable that allows iterating through a range of values.
    let days = 0..31 # 0 to 19

    # A range to infinity
    let numbers = 0..

    # A range can have a step value.
    let evens = 2..2.. # The step value is the `2` in the middle.

    # Using a range in a for loop.
    for i in 0..10:
        print(i)

SPREAD OPERATOR
    # Spread takes the remaining values in a destructure.
    var a, ...b = 1, 2, 3, 4
    print(a) # 1
    print(b) # (2, 3, 4)

    # It is also used for varargs.
    fun rest(a, ...b) = print(b)

    rest(1, 2, 3, 4) # (2, 3, 4)

    # Using the spread operator with object.
    let object = { ...object, extra: 5 }

STRINGS
    let language, year = 'Astro', 2015

    # String interpolation.
    var story = "$language was started in the $year"

    # Both single and double quotes can be used to represent a string literal.
    let calc = '5 * 50 = $(5 * 50)'

    # Non-standard string literals don't have escape sequences nor interpolation.
    var verbatimStr = r."Use '\t' to represent tab"

    # Multiline strings are enclosed in triple `'` or `"` quotes and they ignore all escapes and interpolation
    # The first and last newlines are always ignored in multiline strings.
    var verbatimStr = '''
    Hello, World!
    '''

    # Char is 32-bit that represents a single Unicode codepoint.
    var chars = c.'π'

    # String operations.
    var concatenate = 'ab' ++ 'c' # 'abc'
    var multiply = 'ab' ** 2 # 'abcabc'
    let escapeSequences = '\t \n \' \" \q \\'

    # String continuation.
    var greeting = 'Hello, ' ...
    'World!'

STRING FORMATTING
    # Padding.
    let leftPadding = 'left padding: $:>10(string)'
    let rightPadding = 'right padding: $:<10(string)'
    let placeholderPadding = 'placeholder padding: $:_<10(string)'
    let centering = 'centering: $:^10(string)'

    # Truncation.
    let truncating = 'truncate string: $:.10(string)'

    # Numbers.
    let integer = 'integer: $:d(number)'
    let float = 'float: $:f(number)'
    let truncation = 'figure truncation: $:6.2f(number)'
    let positive = 'positive: $:+d(number)'
    let negative = 'negative: $:-f(number)'

    # Date-Time | Custom objects.
    let date = 'date: $:|Y-m-d H:M|(date)'

MULTILINE EXPRESSIONS
    # Expressions can be continued on the next line by ending the line with a line-continuation punctuator.
    var zero = -100 ...
    + 100

    # If an expression ends the line with a  comma, it is expected to continue on the next line.
    let brother = 'James',
    'Jackcon'

    # If an expression is inside a pair of brackets, it can span multiple lines until a matching closing bracket/brace is encountered.
    let total = (1 + 2 + 3 + 4
    + 5 + 6 + 7)

    # However once the content of a parens are indented, a block is expected, so continuation punctuator is needed for incomplete expression.
    let price = (
        print('price bound to a value')
        add(450, 600)
    )

    let total = (
        1 + 2 + 3 + 4 ...
        + 5 + 6 + 7
    )

    # Chained dot notation or cascading notation can written on subsequent lines but with an indentation.
    sentence
        .trim()
        .lower()

CASCADING NOTATION
    # Cascading notation (using '->') is a variation of dot notation that associates with the initial object instead of on the returned object
    james->name()->print() # Same as `james.name(); james.print()`

WALL NOTATION
    # Wall notation is a syntax sugar for shortening operands with common fields or objects.
    let james = person.name, person.age
    let james = person.|name, age|

    let fullname = james.firstname.lower() ++ james.surname.lower()
    let fullname = james.|firstname ++ surname|.lower()

PASS KEYWORD
    # `pass` keyword can used to represent an empty block.
    fun div(a, b): pass

INDENTATION
    # Astro recognizes 4-space indentations only. No tabs.
    fun removeSpaces(string):
        return s.split(/[ ]/).join()

    fun removeSpaces(string):
      return s.split(/[ ]/).join() # Invalid!

IF EXPRESSION
    # Coonditional branches using `if`, `elif` and `else`.
    if isAdrianRich:
        spendAll('on parties')
    elif isOroboRich:
        spendAll('on legos')
    else:
        cry('we are broke')

    # Checking for nil.
    if phoneNumber: # The block executes if `phoneNumber` is not nil.
        call(phoneNumber)

    # Checking for nil and binding value to a subject.
    if let stockCode = getStockCode('APPLE'):
        print('APPLE: $stockCode')

    # Reassigning a variable from external scope.
    if $player = getPlayer(name):
        print player.fitness

TERNARY OPERATOR
    # The ternary operator is a syntacttc sugar for an if-else expression.
    let cmp = if a > b: 0 else: 1

    # Astro requires parens around the condition.
    let cmp = (a > b) ? 0 : 1

NIL
    # Sometimes, it can be useful to represent an empty or a missing state.
    # This is done with nils in Astro.
    # Non-nillable subjects can give nil nor be assigned a nil value.
    var password = '#5Nj%4VpA391w' #: Str
    password = nil # Invalid!

    # Nillable object can be assigned nil.
    var program = 'print(\"Hello World\")' #: Str|Nil
    var programList = Str()?

    # Nilable unwrap.
    let name = dave?.name

    # Exceptionable unwrap.
    getAccount("Default")! # If result is nil, NilError is raised.

    # Nil coalescing
    let name = getName() ?? "John Doe"

BOOLEAN EXPRESSIONS
    # If x equals y and also greater than z.
    x == y and y == z
    x && z == y
    x == y == z

    # Logical negation with `not` keyword.
    x != y
    not a.isEven()
    i not in list

FOR LOOP
    # A `for` loop iterates through an iterable and binds the value to a subject.
    for i in 1..11:
        print i

    # Destructuring in loop.
    for kind, number in interestingNumbers:
        print '$kind: $number'

    # By default the for loop subjects are immutable, but they can be made mutable using the `var` keyword.
    for var i in 1..21:
        i += 1
        j = i
    ..

    # A `for` loop can be extended with a `where` condiition.
    for i in array where i == 5:
        return i

    # The `end` block executes when a loop completes without interruption like break, return or throw.
    for line in file where /lagbaja/ in line:
        print "name found!"
        break
    end:
        print "name not found!"

COMPREHENSION
    # Comprehension is syntactic sugar for a generator that loops through an iterable.
    let generator = (i | i in random(0, 200))

    # Extending a comprehension with `where`.
    let list = [x | x in 1..21 where x mod 2 != 0]

    # Set comprehension.
    let set = set.[i | i in random(0, 200)]

    # Nested loops.
    let dict = {x : y | x in 1..30; y in 31..60 where even(y)}

BREAK WITH
    # Break-with breaks a loop and returns a value.
    for name in register where name == 'Tony':
            break name
    end: ""

IN
    # `in` is a special keyword-based infix operator that checks for existence of an object in a collection type.
    if student.name in defaulterList:
        print '[student.name] hasn\'t paid yet. Contact parents'

    # Negation.
    if 'ps4' not in birthdayPresents:
        print 'Aaargh! Everyone hates me'

    # Regex matching.
    if /dollar[s]?/ in sentence:
        sentence.replace(/dollar[s]?/, 'pounds')

MOD
    # `mod` is a keyword-based infix operator with the same function as `%`.
    fun isEven(n) = (n mod 2 == 0)

CHAINED CONDITIONAL CONSTRUCTS
    # It is idiomatic in Astro to put, at most, two nested conditional constructs on the same line where possible.
    if person in auditionRoster: if person.mark > 40.0:
        acceptanceList.add person

    # It can significantly reduce the number of indentations.
    fun anyCommonElements(l, r):
        for i in l: for j in r where i == j:
            return true
        false

WHILE LOOP & LOOP
    # Conditional loop.
    while file.hasNext():
        print file.next()

    # Unconditional loop. Synonymous to `while true`.
    loop: # Note, `loop` is not a reserved keyword.
        let input = scan '>>> '
        let tokens = lex input
        let ast = parse tokens
        let bytecodes = compile ast
        let result = interpret bytecodes
        print result

    # A do-while loop block is evaluated at least once.
    do: # Note, `do` is not a reserved keyword.
        print x
        x += 1
    while x < 50

    # Nillable assignment in while loop.
    while let details = books{title}:
        print details
        if details.author != 'J.K. Rowlings':
            break
        title = chooseTitleRandomly()
    ..

    # Like for loop, `while` and `loop` can a following `end` block.
    while file.hasNext() where /\t+/ in file.next():
        break 'File contains tabs!'
    end: 'File is clean!'

MATCH EXPRESSION
    # Match expression is like a chain of if-elif-else expressions that matches against the expression before it.
    # If a match condution is false, it goes to the next condition.
    object
    | Some($x, $y) => 0 # Matches if object is of `Some` type with values of subject `x` and `y` declared in the outer scope.
    | Some(x, y) => 1 # Matches if object is of `Some` type and binds `x` and `y` to Some's fields.
    | 75 || 67 => 2 # Matches if object has value `75` or value `67`
    | 75 && 67 => 3 # Matches if object has value `75` and value `67`
    | _ > 75 => 4 # Matches if `object > 75`
    ! 75 => 5 # Matches if object doesn't have value `75`
    | 75 => spill # `spill` keyword means the control flow should unconditionaly move to the next match condition.
    | n => 6 # Matches. Binds `n` to the object.
    | _ => 7 # Matches.

    # A match block can be written on a single line but it is not advised.
    fun whatNumber(n) = | 1 => 'One' | 2 => 'Two' | _ => 'Other'

    # A do-match expression passes its result as an argument to a preceding function call
    print _ where fruit
    | 'grape' => 'They\'re Berries! Yes, grapes are a kind of berry.'
    | 'apple' => 'Apple trees take four to five years to produce their first fruit.'

    # A match expression can also be used to match against the arguments of a function, if, for, loop or while expressions.
    fun isChosen(option):
        | 'y' || 'Y' => true
        | 'n' || 'N' => false
        | _ => raise Error('Invalid choice!')

ASSIGNMENT DESTRUCTURING
    # Instead of separately binding subjects to objects fields, it can be done in a single expression with destructuring.
    let name = person.name
    let age = person.age
    let { name, age } = person

    # Destructuring patterns for other data structures
    let [name, age, _, ...rest] = [1, 2, 3, 4, 5]
    let [name, age, _, ...rest] = set.[1, 2, 3, 4, 5]
    let (a, b, _, ...c) = (1, 2, 3, 4, 5)
    let a, b, c = (1, 2, 3, 4, 5)
    john.|name, age| = ('John', 45)

SCOPE LABELLING
    # Labels allow the programmer to specify the scope a control primitive (e.g. break, yield, return) affects using the `at` keyword.
    for line in file: @(outer)
        for c in line where c == '\t':
            break at outer # breaks the outer loop
    ..

    # Labelling a function.
    @(top)
    fun outer(object):
        fun inner():
            return object.value at top
    ..

EXT KEYWORD
    # `ext` can be used to refer to the parent scope.
    let state = 'Idle'

    fun change(state): #: T?
        if state != nil:
            enable state
        else:
            enable ext.state # `ext.state` refers to `state` of the outer scope
    ..

MAIN FUNCTION
    # If a module contains a main function, it will be the module's entry point.
    fun main():
        print 'Hello World!'

FUNCTION DEFINITION (2)
    # If a function returns nothing, it can either be annotated with None or left empty.
    fun show(point): #: (Point) -> None
        print(point.|a, b|)

    # The normal order of arguments in a function call can be changed if the parameter name is specified.
    fun say(msg, name): #: (Str, Str)
        print '$msg $name!'
    ..
    say(name: 'Steve', 'Hello') # Hello Steve!

    # Varargs takes variable number of arguments.
    fun arithMean(...numbers):
        var total = 0
        for number in numbers:
            total += number
        total / numbers.size
    ..
    arithMean(1, 2, 3, 4) # It can take multiple arguments.
    arithMean(...tuple) # Or a spread tuple.

    # Anonymous functions are functions without names.
    fun _(): return a + b

    # Default parameter values.
    fun login(username: 'demo', password: 'demo'):
        access Account(username, password)
    ..
    login() # Using default values.

    # Compulsory named parameters are marked with `.`.
    fun signUp(username., password.):
        access Account(username, password)

    # The parameter names must be specified in the function calls.
    signUp(username: 'appcypher', password: 'bazinga!')
    signUp('appcypher', 'bazinga!') # Invalid!

    # Compulsory named parameters can have a different name that can be used within the function block.
    fun send(message, to.recipient):
        print((message + recipient).upper())
    ..
    send('Hello', to:'Cantell')

    # Compulsory named can also be used with varargs, which would then be a named tuple.
    fun total(start, ...rest.):
        let result = start
        for i in rest: result += i
        result
    ..
    total(0, watch: 500, shoes: 6700, laptop: 1200)

    # Destructuring parameters.
    fun show({name, age}) = print(name, age)

    # A function's arguments can be accessed as a named tuple via _args.
    fun printPerson(name, age) = print(_args)
    printPerson('John', 25) # (name: 'John', age: 25)

    # Astro supports Unified Function Call Syntax (UFCS), so a function can be called with using the dot notation.
    print(500)
    500.print()

LAMBDAS
    # Functions are first-class objects and can be passed around like regular objects.
    let scoresExtraMarks = scores.map(fun _(score): score + 5)
    scores.each(print)

    # Assigning a function to a subject.
    let add = +
    add(4, 5) # 9

    # Lambdas are syntactic sugar for anonymous functions.
    fixtureList.filter(fun _(game): not game.isCancelled) # Anonymous function.
    fixtureList.filter(|game| => not game.isCancelled) # Lambda.

    # When a function call takes a single function argument, the lambda can be written after the call parens.
    list.foldl(0) |x, y| => x + y

    # The call parens can be ommitted if all the function takes is a function argument.
    list.each |x| => print(x)

    # Recursive lambda.
    # An anonymous function or lambda can be recursively called within its body using the fun keyword.
    list.aggregate(0) |a| => (a == 0) ? 1 : (a + fun(a - 1))

CLOSURE
    # A closure is a function defined within another function.
    fun genDbConnector(host., username., password.):
        return fun makeDbConection(): # A closure can aslo be returned.
            db.connect(host, username, password)
    ..

PARTIAL APPLICATION
    # Partially applied functions are function calls with one or more of it's argument not applied.
    fun multiply(a, b) = a × b

    # Unapplied arguments are represented with the placeholder, `$`.
    let multiply3by = multiply(3, _)

    # Applying missing arguments.
    multiply(3, _)(5) # 15
    multiply3by(5) # 15

IMMEDIATELY INVOKED FUNCTION EXPRESSION (IIFE)
    # Non-idiomatic IIFE in Astro.
    (|a, b| => a + b)(2, 3)

    # Idiomatic version.
    (a: 2, b: 3) => a + b

    # An IIFE can be take subjects from enclosing scope as arguments.
    let a, b = 2, 3
    (a, b) => a + b

    # An IIFE with no argument.
    () => print('Hello world!')

COROUTINES & GENERATORS
    # A coroutine is a type of function that can pause and resume its execution.
    # `yield` marks execution pause and resumption point.
    fun count(num):
        for x in ..num: yield x

    # Instantiating the coroutine.
    var counter = count(25)

    # Calling the coroutine.
    count.next() # 0
    count.next() # 1
    count.next() # 2

    # `delegate` redirects a coroutine through another coroutine.
    delegate coroutine

TYPE DEFINITION (2)
    # Defining a type.
    type Car:
        var make
        var year

    # Types need constructors for object creation. A constructor always has the same name as the type.
    # The special `new` function creates a new object of the particular type.
    fun Car(make, year) = new(make, year)
    let ride = Car('Camaro', 2016)

    # New constructor cannot be defined outside the module its type is defined in.

    # A constructor that contains just a `new` function call can be shortened further.
    fun Car(maker, year)

    # Constructor types are a syntax sugar for merging type and corresponding constructor definitions together.
    type Car(var make, var year)
    let ride = Car('Camaro', 2016)

    # On the other hand, a type can have a destructor.
    # Destructor can be used for last-nanosecond cleanups before an object is destroyed.
    # The object can be referenced in the destructor body with `self`
    fun Car(!) = print('deleting car: ', self.|make, year|)

GENERICS
    # Uppercase single letter identifier are reserved for generic type annotations.
    # Declaring a generic type T.
    fun add(a, b): #: (T, T) -> T
        return a + b

    # Type argument can be ommited if the type argument can be readily inferred.
    var sum = add[Int](2, 4)
    var sum = add(2, 4) # Type argument inferred

    # Getting more expressive generic type annotation with `where` and type relation opeartors (`::`, `<:`, `>:`)
    fun anyCommonElements(l, r): #: (T, U) -> Bool where (T, U)<:Sequence
        for x in l: for y in r where x == y:
            return true
        false

    # `_` is placeholder for type parameters that should be inferred by the compiler.
    #: (Seq, _) -> T where T::Seq.T
    fun getItem(list, index):
        list[index]

    # Nillable type annotation
    let language #: Str|Nil
    let language #: Str?

    # List type annotation
    let languages #: List[Str]
    let languages #: [Str]

    # Value contraints allow the programmer to specify certain contraints on the value of a type.
    # Note: Value constraints are subject declarations in their own right and can cause name clashes.
    var age #: Int(1..120) # age is an int value that must be between 1 and 120
    var name #: S() where S::Str # S is any value of type Str

TYPE CONVERSION
    # In Astro, the lowercase version of type names are usually meant for conversion operations.
    var three = int(3.14159265358) # Converts to Int
    var five = str(5) # Converts to Str

INHERITANCE
    # Types can inherit from one or more parent types in Astro.
    type Animal
    type Bird <: Animal # Bird type inherits fields from Animal.
    type Horse <: Animal  # Horse type inherits fields from Animal.

    # Multiple inheritance is allowed as well.
    type Pegasus <: Horse, Bird:  # Pegasus inherits Horse, Bird.

MULTIPLE DISPATCH
    # Astro uses a covariant multiple dispatch system.
    # The most specific function is always called based on the number and types of the arguments.
    fun foo(a, b) = print('generic') #: (Int32, Real)
    fun foo(a, b) = print('specific') #: (Int32, Int32)

    foo(4, 5.0) # generic
    foo(4, 5) # specific

    # The compiler can be made to call a less specific version of a function using the `as` keyword.
    foo(4, 5) as (_, Real) # generic

    # `super` can be used in this case. It calls a version with a parent type.
    foo(4, 5) as (_, super) # generic

METHOD RESOLUTION AMBIGUITIES
    # There are some ambiguities that can arise with multiple inheritance and multiple dispatch.
    # Ambiguity error occurs when a type inherits from types that have different specific implementations of function.
    fun sound(bird) = print('chirp!') #: Bird
    fun sound(horse) = print('neigh!') #: Horse
    type Pegasus <: Horse, Bird # Error!

    # To resolve this issue, the `sound` function need to be overloaded for `Pegasus` type.
    fun sound(pegasus) = print('neigh! chirp!') #: Pegasus

    # Ambiguity error can also occur when the arrangement of type paramters causes multiple dispatch ambiguity.
    fun foo(a, b) = print('fizz') #: (Int32, Real)
    fun foo(a, b) = print('buzz') #: (Real, Int32)
    foo(1, 2) # Error!

    # A more specific function need to be provided
    fun foo(a, b) = print('fizz') #: (Int32, Int32)

CONSTRUCTOR TRAIN
    # Astro follows the principle that each type should be responsible for the initialisation of the fields it introduces to an inheritance tree.
    # Constructor train is Astro's way of ensuring declared and inherited fields of a particular type are initialized on object creation.
    type Person(name)
    type Teacher(subject) <: Person
    type Student(course) <: Person

    # The initialization of inherited field is delegated to the parent's constructor, `super`.
    fun Teacher(name, subject) = new(subject).super(name)

    # In the case of multiple inheritance, the individual parent constructors are called and chained to the `new` function.
    type TeachingStudent(schedule) <: Teacher, Student
    fun TeachingStudent(name, subject, course, schedule):
        new(schedule).Student(name, course).Teacher(_, subject)

ABSTRACT TYPES & FUNCTIONS
    # Abstract types cannot be instantiated.
    abst Player
    var p = Player() #: Error!

    # A function without a body is an abstract function and an error will be raised if called directly.
    fun rewind(player) #: Player
    rewind(p) #: Error!

    # An abstract type can have fields which can only be declared as parameters rather than in the body.
    abst Human(name, age)
    abst Human: var name, age # Invalid!

    # Abstract types can have subtypes declared within them effectively making them algebraic data types.
    abst Tree:
        | Leaf(value) #: (T) -> Leaf
        | Node(l, r) #: (Leaf, Tree) -> Node

    # The block begin punctuator, `:`, can be replaced with `=` for single expression definitions.
    abst Platform = Web | Mobile | Desktop

TYPE CHECKING
    # The `typeof` operator can be used to get an object's type.
    typeof 50 # Int32

    # `::`, `>:`  and `>:` are operators for checking type relations.
    50 :: Integer # Exact type check.
    50 <: Integer # Subtype check.
    50 >: Integer # Supertype check.

    # A more complex type checking.
    head([1, 2, 3]) :: ([Int]) -> Int

TYPE ALIASES
    # A single or set of types can be given an alias
    type Number = Integer | Float | Complex
    fun add(a, b) = a + b #: (Number, Number) -> Number

REFERENCE EQUALITY
    # `is` operator can be used check if two operands refer to the same object internally.
    let a = 'Hi'
    let b = 'Hey'
    let c = a
    a is b # false
    a is c # true

MODULES & IMPORT
    # Importing a module.
    import quaternion
    let quat = quaternion.mat2quat([1, 2; 3, 4])

    # Exported members of a module can be imported directly into the current namespace.
    import quaternion { mat2quat }
    let quat = mat2quat([1, 2; 3, 4])

    # Importing all exported members of a module.
    import math { ... }

    # Importing multiple modules
    import csv, dataframes

    # Module path can be specified following the Unix style.
    # Module names also follow Unix style.
    import nypro/../my-cool-new-project

    # Renaming can help disambiguate imports.
    import fastmath:nypro/fast-math { cosine:cos, sine:sin, π:pi }
    let b = fastmath.tan(45)
    let d = cosine(30)

    # Aggregate module
    # A single module can be split between different files by numbering them.
    # `vector.ast`, `vector-1.ast`, `vector-2.ast`, etc. all combine as a single module.
    import vector

EXPORT
    # Subjects, functions and types declared within the current module can be exported using the 'export' keyword.
    export { cos, sin, tan }

    # If only a single module member is being exported, the braces can be ommitted.
    export sin

    # There can only be one export statement in a module and it is expected to be defined at the
    # bottom of the file.
    import random { randoms }
    fun randomString() = randoms(10).map str
    export randomString

PRIVATE ACCESS MODIFIER
    # The private access punctuator, `'`, is used in areas where the export keyword can't cover
    # When a function name is exported, every overload of the function is exported. That can be undesirable sometimes.
    # `'` can be used to mark the overloads we don't want to export
    fun add(a, b) = a + b
    fun add'(a, b, c) = a + b + c #'
    export add # The second add function won't be exported

    # Also, while type names can be exported, sometimes it is necessary to make a field private.
    type Student:
        var name
        var scores' #' #`Student.scores` can only be accessed within the module

OPERATORS
    # Operators are special characters (+-/\&|=%$ ...) and can be combined to form new names.
    # Operators are different from regular identifiers in the way they are used. There are:
    # Prefix operators, with the operator preceding its operand.
    let negation = +500

    # Postfix operators, with the operator coming directly after its operand.
    let squared = 4²

    # Infix operators, with the operator in between its operand.
    let addition = 5 + 8

    # Operators and Spacing.
    # Prefix or postfix operators cannot have spaces between them and the operand.
    let negation = + 500 # Invalid!
    let squared = 4 ² # Invalid!

    # An infix operator can either have spaces on both sides or not have spaces at all.
    let addition = 5+8
    let addition = 5 + 8
    let addition = 5 +8 # Invalid!
    let addition = 5+ 8 # Invalid!

    # Operators cannot be combined with normal identifiers or special characters/punctuators like .,`@(){}[] to form new names.
    let pl*s = 5 # Invalid!

OPERATOR OVERLOADING & CUSTOM OPERATOR
    # Existing operators can be overloaded just like regular functions.
    fun +(x, y): #: (Dual, Dual) -> Dual
        Dual(|x + y|.vl, |x + y|.adj)

    # New operators can also be created by combining operators as a name.
    fun ++(x): #: (Real, Real) -> Real
        var temp = val x
        x += 1
        return temp

    # Special operators like [] and {} can be overloaded using their alternative identifier names.
    fun getIndex(sequence, index): #: (Sequence, Signed)
        return sequence.items[index]

TRY, EXCEPT & ENSURE
    # Raising an exception with the `raise` keyword.
    if numerator && denominator == 0:
        raise DomainError()

    # Handling an exception
    # Ensure block is optional, but when it is present, it is always run.
    try:
        process bigData
    except err: #: IncompleteDataError
        print err.msg
    ensure:
        restore bigData

    # The except body can be ommitted if it's only printing the error message.
    try: process bigData
    except err #: IncompleteDataError

    # An object defined in the try's header always has it's at the end of the try block.
    try file = open('dancing-masquerade.txt'):
        for line in file: print line

SYMBOL
    # Symbols are static data types that hold their content as-is.
    let symbol = $(2 + 3)

    # A symbol can be interpolated with another symbol using '\'.
    let addition = $(let five = + \symbol)

    # A symbol can be evaluated with the 'eval' keyword.
    eval addition

REGEX
    # Regex are used to find and/or capture patterns in strings.
    var numberPattern = /\d+(.\d+)?/
    numberPattern in 'π = 3.14159265' # true

    # Regex operations.
    var = /\d/ ++ re.'\[a-z]' ++ /\d/ # Concatenation

NON-STANDARD LITERAL
    # Non-standard literals allow users to use existing literals to define new literals.
    var price = 35'USD #'
    var soup = utf32.'😋🍜'
    var numbers = sorted.[2, 4, 3, 5, 1]
    var books = sorted.{ "Harry Potter": "J.K. Rowling", "Ender's Game": "Orsen Scott" }
    let arguments = set.(2, 4, 5, 4)
    let people = merge.(name: 'Steve', age: 15, name: 'John', age: 24)

COEFFICIENT EXPRESSION
    # Coefficient expression allows an identifier after a numeric literal to be taken as multiplication.
    let x = 3 * f + 2 * (6 + 1)
    let x = (3)f + 2(6 + 1)
    let x = 3f + 2(6 + 1)

    # Because of this syntactic sugar, Numeric types cannot be made callable.
    fun call(i, ...args) = i + sum(args) #: Int # Invalid!

    # Note: In the case of hex literal, coefficient expressions are not permitted.
    let h = 0x344f # f is not considered a variable here, but part of the hex literal.
    let h = 0x344j # Invalid!
    let h = (0x344)f


INTEGER BITWISE OPERATORS
    # Bitwise `or` changes the bit to `1` if the corresponding bit in either operand is `1`.
    var x = 2 | 5

    # Bitwise `and` changes the bit to `1` if the corresponding bits in both operands are `1`.
    var y = 3 & 6

    # Bitwise `not` Inverts the bits of its operand.
    var z = ~6

    # Bitwise `xor` changes the bit to `1` if corresponding bits in operands are not both `1`.
    var a = ^7

    # Bitwise `left shift` moves the bits in `a` to the left `b` times.
    var b = a << b

    # Bitwise `right shift` (sign propagation) moves the bits in `a` to the right `b` times.
    # It shifts in the sign bit from the left.
    var c = b >> a

    # Bitwise `right shift` (zero propagation) moves the bits in `a` to the left `b` times.
    # It shifts in the `0`s from the left.
    var c = b >>> a

POINTERS
    # Creating a pointer to a primitive object address.
    let num = 55
    let pointer = ptr(num)

    # Setting value of pointed location.
    pointer.value = 57

    # Change pointer address # Problematic!
    pointer.addr = 0xFFFE

    # Allocating memory on the heap.
    let memory = malloc[Byte](5) # Allocates 5 bytes on the heap.

    # Freeing memory.
    free(memory) # Compile-time error will be throws if there is a possible dangling or pointer aliasing problem.

    # Pointer arithmetic is not normally supported in Astro, however a pointer to a block of memory can be incremented or decremented but with bounds checking.
    let memory = malloc[Int](20)
    let pointer = memory[2]
    pointer.offset(5)
    pointer.offset(500) # Error!

RESERVED KEYWORDS
    import, export, let, var, fun, type, abst, async,
    if, elif, else, while, for, try, except, ensure, defer, loop, unsafe
    spill, return, raise, break, continue, yield, delegate, await,
    where, at,
    eval,
    is, not, in, as, mod, typeof,
    new, super,

PREDEFINED TYPE HIERARCHY
    Type
    Any
        Function
        Scalar
            Real
                Integer
                    Signed
                        Int, Int8, Int16, Int32, Int64,
                    Unsigned
                        UInt, UInt8, UInt16, UInt32, UInt64
                Float
                    Float32, Float64
            Complex
                Complex64, Complex128
            Bool
        Seq
            List
            Array
            Range
            Indexer
            Tuple
            NamedTuple
            Dict
            Generator

TYPE ASSERTION
    add(3, 4) :: (Int, Int) -> Int
    type Car(make, year) :: Type{Car}
    Car('', '') :: Car{Str, Str}
